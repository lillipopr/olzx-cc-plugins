# 领域架构师知识库整合方案

## 一、整合目标

将规格编译器 4.0 的 Phase 1-3（问题建模、约束定义、用例设计）整合到领域架构师知识库，形成统一的 DDD 设计体系。

### 核心变化

| 维度 | 整合前 | 整合后 |
|------|--------|--------|
| 职责分工 | 领域架构师做战略设计 → 规格编译器做战术设计 | 领域架构师完成从战略设计到用例设计的全流程 |
| 文档输出 | 分散的多份文档 | 统一的《领域设计文档》 |
| 方法论 | DDD 经典方法 + 规格编译器方法 | 整合后的 DDD 规格设计方法论 |
| 模板数量 | 4 个模板 | 1 个最终输出模板 |

---

## 二、整合后的领域架构师职责

### 2.1 职责范围（完整）

```
领域架构师能力体系
│
├── 战略设计（Strategic Design）
│   ├── 业务能力分析
│   ├── 限界上下文划分
│   ├── 上下文映射
│   └── 架构愿景
│
├── 战术设计（Tactical Design）
│   ├── 聚合设计
│   ├── 实体与值对象
│   ├── 领域事件
│   ├── 领域服务
│   └── 仓储接口
│
└── 规格设计（Specification Design）★ 新增
    ├── Phase 1: 问题建模（状态空间定义）
    ├── Phase 2: 约束定义（可执行约束）
    └── Phase 3: 用例设计（测试用例）
```

### 2.2 工作流程

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    领域架构师完整工作流程                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  输入：PRD 文档                                                           │
│    ↓                                                                     │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │ 第一部分：战略设计                                                │    │
│  │  1. 业务能力分析 → 识别核心业务能力                               │    │
│  │  2. 限界上下文划分 → 按业务能力拆分上下文                         │    │
│  │  3. 上下文映射 → 定义上下文间关系                                 │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│    ↓                                                                     │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │ 第二部分：战术设计 - 统一建模                                      │    │
│  │  1. 聚合设计 → 识别聚合根、确定聚合边界                            │    │
│  │  2. 实体/值对象 → 区分实体与值对象                                │    │
│  │  3. 领域事件 → 定义领域事件                                       │    │
│  │  4. 领域服务 → 识别领域服务                                       │    │
│  │  5. 仓储接口 → 定义仓储接口                                       │    │
│  │  6. 应用层接口 → 行为列表（用户行为 + 系统行为）                   │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│    ↓                                                                     │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │ 第三部分：约束定义                                                │    │
│  │  1. 状态定义表 → 定义每个实体的状态空间                           │    │
│  │  2. 状态转移表 → 定义合法的状态变化路径                           │    │
│  │  3. 不变量清单 → 定义系统必须满足的约束                           │    │
│  │  4. 禁止态说明 → 明确系统不允许进入的状态                         │    │
│  │  5. 约束执行时机表 → 定义约束何时执行                             │    │
│  │  6. 约束违反处理策略 → 定义违反约束时的处理方式                   │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│    ↓                                                                     │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │ 第四部分：用例设计                                                │    │
│  │  1. 正向用例 → 覆盖所有 Happy Path                               │    │
│  │  2. Bad Case → 覆盖所有禁止态                                    │    │
│  │  3. 边界用例 → 覆盖边界条件                                      │    │
│  │  4. 用例覆盖矩阵 → 验证覆盖完整性                                │    │
│  │  5. 用例优先级 → 定义实现优先级                                   │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│    ↓                                                                     │
│  输出：《{功能名称} - 领域设计文档》                                      │
│    ↓                                                                     │
│  使用 Checklist 校验每一部分是否符合设计原则                               │
│    ↓                                                                     │
│  等待用户 Review → 如有问题则修改                                         │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 三、文件组织结构调整

### 3.1 新的目录结构

```
skills/for-domain-architect/
│
├── SKILL.md                          # 入口文档
│
├── sop/                              # 标准作业流程
│   ├── sop-main-flow.md             # 主流程（整合后的完整 SOP）
│   ├── sop-strategic-design.md      # 战略设计 SOP
│   ├── sop-tactical-design.md       # 战术设计 SOP
│   ├── sop-constraints.md           # 约束定义 SOP（来自 spec-compiler-v4）
│   └── sop-use-cases.md             # 用例设计 SOP（来自 spec-compiler-v4）
│
├── methodology/                      # 方法论
│   ├── 实体抽取方法论（整合）
│   ├── 状态空间设计（来自 spec-compiler-v4）
│   ├── 不变量定义（来自 spec-compiler-v4）
│   ├── 约束伪代码规范（来自 spec-compiler-v4）
│   ├── 用例设计方法（来自 spec-compiler-v4）
│   └── 意图vs事实（来自 spec-compiler-v4）
│
├── principles/                       # 设计原则
│   ├── ddd-principles.md            # DDD 核心原则
│   ├── aggregate-principles.md      # 聚合设计原则
│   ├── modeling-principles.md       # 建模原则
│   └── invariant-principles.md     # 不变量设计原则（新增）
│
├── patterns/                         # 设计模式
│   ├── ddd-patterns.md              # DDD 战略模式
│   └── tactical-patterns.md         # DDD 战术模式
│
├── checklists/                       # 检查清单
│   ├── strategic-checklist.md       # 战略设计检查清单
│   ├── tactical-checklist.md        # 战术设计检查清单
│   ├── constraint-checklist.md     # 约束检查清单（新增）
│   └── use-case-checklist.md       # 用例检查清单（新增）
│
├── templates/                        # 模板
│   └── domain-design-template.md    # 唯一模板：领域设计文档模板
│
├── knowledge/                        # 领域知识
│   ├── bounded-context.md
│   ├── aggregate-lifecycle.md
│   └── ubiquitous-language.md
│
└── scenarios/                        # 场景 SOP（新增）
    ├── new-feature.md               # 新功能场景
    ├── bug-fix.md                   # Bug 修复场景
    ├── feature-change.md            # 功能变更场景
    └── review-existing.md           # Review 已有文档场景
```

### 3.2 删除/归档的文件

**模板目录归档**（只保留 1 个模板）：
- ~~tpl-context-partition.md~~ → 归档
- ~~tpl-aggregate.md~~ → 归档
- ~~tpl-domain-event.md~~ → 归档
- ~~tpl-ddd-design.md~~ → 归档

**保留**：
- domain-design-template.md（新的统一模板）

---

## 四、方法论整合要点

### 4.1 实体抽取方法论（整合）

将 spec-compiler-v4 的实体抽取方法论整合到 DDD 语境：

| 原文档 | 整合后 |
|--------|--------|
| spec-compiler-v4 的三个必要条件 | DDD 实体识别的三个条件 |
| 意图 vs 事实 区分 | DDD 应用层 vs 领域层职责划分 |
| 行为分类 | DDD 领域服务 vs 应用服务 |

### 4.2 状态空间设计（新增）

来自 spec-compiler-v4，整合为 DDD 建模的核心方法：

- 状态定义：完备且互斥
- 状态转移：合法路径定义
- 禁止态：明确非法状态
- 状态转移表：统一定义格式

### 4.3 不变量定义（新增）

来自 spec-compiler-v4，整合为 DDD 约束设计方法：

- 不变量三测试：可执行、可测试、可解释
- 不变量分类：结构、业务、状态、版本、可解释性
- 不变量收敛原则：一个实体 = 一组必须被一起保护的不变量

### 4.4 约束伪代码（新增）

来自 spec-compiler-v4，作为跨端一致的约束表达方式：

- 统一伪代码语法
- 不绑定具体语言
- 各端实现位置映射

### 4.5 用例设计（新增）

来自 spec-compiler-v4，整合为 DDD 验证方法：

- 正向用例、Bad Case、边界用例
- 用例覆盖矩阵
- 用例优先级

---

## 五、统一的领域设计文档模板

### 5.1 模板结构（用户确认的结构）

```markdown
# {功能名称} - 领域设计文档

## 第一部分：战略设计
1. 业务能力分析
2. 限界上下文划分
3. 上下文映射

## 第二部分：战术设计：统一建模
1. 聚合设计
2. 聚合根、实体、值对象
3. 领域事件
4. 领域服务
5. 仓储接口
6. 应用层接口：行为列表（用户行为 + 系统行为）

## 第三部分：约束定义
1. 状态定义表
2. 状态转移表
3. 不变量清单
4. 禁止态说明
5. 约束执行时机表
6. 约束违反处理策略

## 第四部分：用例设计
1. 正向用例
2. Bad Case
3. 边界用例
4. 用例覆盖矩阵
5. 用例优先级
```

### 5.2 各部分详细内容

#### 第一部分：战略设计

| 章节 | 内容 | 产出 |
|------|------|------|
| 业务能力分析 | 业务能力树、能力分级、能力与团队对齐 | 业务能力图 |
| 限界上下文划分 | 按业务能力拆分、上下文类型识别 | 上下文图 |
| 上下文映射 | 上下游关系、集成模式 | 上下文映射图 |

#### 第二部分：战术设计

| 章节 | 内容 | 产出 |
|------|------|------|
| 聚合设计 | 聚合根识别、聚合边界确定 | 聚合图 |
| 实体/值对象 | 实体列表、值对象列表 | 实体清单 |
| 领域事件 | 事件定义、事件触发条件 | 事件清单 |
| 领域服务 | 服务识别、服务职责 | 服务清单 |
| 仓储接口 | 仓储定义 | 接口清单 |
| 应用层接口 | 用户行为 + 系统行为 | 行为清单 |

#### 第三部分：约束定义（来自 spec-compiler-v4）

| 章节 | 内容 | 产出 |
|------|------|------|
| 状态定义表 | 每个实体的状态空间 | 状态定义表 |
| 状态转移表 | 合法的状态变化路径 | 状态转移表 |
| 不变量清单 | 系统约束（可执行伪代码） | 不变量清单 |
| 禁止态说明 | 不允许进入的状态 | 禁止态清单 |
| 约束执行时机表 | 约束何时执行 | 执行时机表 |
| 约束违反处理策略 | 违反约束时的处理方式 | 处理策略表 |

#### 第四部分：用例设计（来自 spec-compiler-v4）

| 章节 | 内容 | 产出 |
|------|------|------|
| 正向用例 | Happy Path 覆盖 | 正向用例清单 |
| Bad Case | 禁止态验证 | Bad Case 清单 |
| 边界用例 | 边界条件覆盖 | 边界用例清单 |
| 用例覆盖矩阵 | 验证覆盖完整性 | 覆盖矩阵 |
| 用例优先级 | 实现优先级 | 优先级表 |

---

## 六、工作流程（SOP）

### 6.1 SOP-1：从 PRD 到领域设计文档

```
1. 读取 PRD 文档
2. 战略设计
   a) 业务能力分析
   b) 限界上下文划分
   c) 上下文映射
3. 战术设计
   a) 聚合设计
   b) 实体/值对象识别
   c) 领域事件定义
   d) 领域服务识别
   e) 仓储接口设计
   f) 应用层接口设计
4. 约束定义
   a) 状态空间定义
   b) 状态转移定义
   c) 不变量定义（伪代码）
   d) 禁止态定义
5. 用例设计
   a) 正向用例设计
   b) Bad Case 设计
   c) 边界用例设计
   d) 覆盖矩阵生成
6. 使用 Checklist 校验
7. 输出《领域设计文档》
8. 等待用户 Review
```

### 6.2 SOP-2：Review 已有领域设计文档

```
1. 读取已有领域设计文档
2. 使用 Checklist 逐项检查
3. 指出问题（引用最佳实践）
4. 给出修改建议
5. 等待用户确认
6. 修改生成新版本
7. 使用 Checklist 校验
8. 等待用户 Review
```

---

## 七、核心设计原则

### 7.1 理论依据

| 原则 | 来源 | 说明 |
|------|------|------|
| 聚合设计 | Eric Evans DDD | 实体收敛原则 |
| 不变量约束 | Bertrand Meyer | 面向对象软件构造 |
| 状态机建模 | David Harel | 状态图在软件设计中的应用 |
| 约束优先级 | Michael Jackson | 问题框架方法 |

### 7.2 跨端一致性原则

- **Phase 1（问题建模）**：跨端唯一
- **Phase 2（约束定义）**：跨端一致（伪代码不绑定语言）
- **Phase 3（用例设计）**：跨端一致（相同用例，各端验证）

---

## 八、实施步骤

### 步骤 1：备份现有文件
```bash
# 备份 templates 目录
cp -r templates templates-backup

# 备份 spec-compiler-v4 相关文件
cp -r ../for-spec-compiler-v4 ../for-spec-compiler-v4-backup
```

### 步骤 2：删除旧模板
```bash
# 只保留 domain-design-template.md，其他归档
mkdir templates-archive
mv templates/tpl-*.md templates-archive/
```

### 步骤 3：创建新文件
- 主流程 SOP：sop/sop-main-flow.md
- 约束 SOP：sop/sop-constraints.md（迁移自 spec-compiler-v4）
- 用例 SOP：sop/sop-use-cases.md（迁移自 spec-compiler-v4）
- 不变量原则：principles/invariant-principles.md（新增）
- 约束检查清单：checklists/constraint-checklist.md（新增）
- 用例检查清单：checklists/use-case-checklist.md（新增）
- 统一模板：templates/domain-design-template.md（新建）

### 步骤 4：整合方法论
- 实体抽取：整合 spec-compiler-v4 的方法论到 DDD 语境
- 状态空间设计：新增方法论文档
- 不变量定义：新增方法论文档
- 约束伪代码：新增规范文档
- 用例设计：新增方法论文档

### 步骤 5：更新 SKILL.md
更新领域架构师的职责描述和工作流程

### 步骤 6：更新 SKILL.md（主入口）
更新技能文档，反映新的知识结构

### 步骤 7：更新相关 Agent
更新 domain-architect Agent 的职责描述

---

## 九、检查清单（整合完成后）

### 文件完整性
- [ ] 主流程 SOP 创建完成
- [ ] 约束 SOP 创建完成
- [ ] 用例 SOP 创建完成
- [ ] 不变量原则创建完成
- [ ] 约束检查清单创建完成
- [ ] 用例检查清单创建完成
- [ ] 统一模板创建完成
- [ ] 旧模板已归档

### 内容一致性
- [ ] spec-compiler-v4 的方法论已整合
- [ ] DDD 原则与新方法论协调一致
- [ ] 模板结构与用户确认的一致
- [ ] SOP 流程清晰可执行

### 质量验证
- [ ] 每个方法论都有理论依据
- [ ] 每个原则都有最佳实践参考
- [ ] 检查清单覆盖所有设计环节
- [ ] 模板可直接使用

---

## 十、后续工作（不在本次范围）

- spec-compiler-v4 的 Phase 4（端到端接口设计）保留在原位置
- spec-compiler-v4 Agent 的职责调整（不再负责 Phase 1-3）
- 相关 Agent 间的协作流程更新
