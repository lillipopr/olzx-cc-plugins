---
description: 代码重构流程，规划重构范围 → 执行 → 验证，每个阶段强制 planner 控制
---

# /dev-refactor - 代码重构流程

## 功能

启动代码重构流程，**严格的多阶段规划控制**：先规划重构范围，再执行重构，最后验证。

## 使用方式

```
/dev-refactor
/dev-refactor {重构目标}
```

## 完整流程

```
┌─────────────────────────────────────────────────────────────┐
│ Phase 1: 重构规划                                           │
│   planner → code-reviewer → checkpoint                      │
├─────────────────────────────────────────────────────────────┤
│ Phase 2: 重构执行                                           │
│   planner → {Java/iOS/frontend}-expert → checkpoint         │
├─────────────────────────────────────────────────────────────┤
│ Phase 3: 验证与审查                                         │
│   planner → code-reviewer → checkpoint                      │
└─────────────────────────────────────────────────────────────┘
```

## 启动提示

```
🔧 启动代码重构流程

将按以下流程执行：
1. Phase 1: 重构规划（识别问题、定义范围）
2. Phase 2: 重构执行（执行重构、保持测试通过）
3. Phase 3: 验证与审查（确保质量、无行为变化）

⚠️  严格的多阶段规划控制：
   - 每个 Phase 开始前强制使用 planner 拆解任务
   - 每个 Phase 执行后强制 checkpoint 验收
   - 重构原则：不改变外部行为，只改善内部结构

请描述您要重构的目标：
```

---

## Phase 1: 重构规划

### Step 1: 调用 Planner

```
📋 Phase 1: 重构规划 - 规划

请调用 planner，规划本阶段的执行步骤：

规划要求：
1. 分析重构目标，识别问题
2. 拆解为原子任务（代码分析、问题识别、范围定义等）
3. 定义每个任务的验收标准
4. 标记关键检查点
5. 预估执行时间

输出格式参见 /dev 命令中的 "Planner 输出格式"
```

### Step 2: 执行 Agent

- **Agent**: `agents/code-reviewer/AGENT.md`（或项目中的 review agent）
- **Skill**: `skills/for-code-reviewer/SKILL.md`（如果有）
- **核心任务**:
  1. 代码分析：识别当前代码的问题
  2. 问题分类：复杂度、可读性、可维护性、性能等
  3. 重构范围：定义需要重构的模块和优先级
  4. 风险评估：识别重构可能带来的风险

### Step 3: Checkpoint 验收

```
📋 Phase 1 Checkpoint

### 规划回顾
- 规划步骤数: {总数}
- 已完成: {数量} ✅

### 逐项验收
- [ ] 代码问题已识别
- [ ] 问题已分类（复杂度/可读性/可维护性/性能）
- [ ] 重构范围已定义
- [ ] 重构优先级已排序
- [ ] 风险已评估
- [ ] 重构计划文档已生成

### 偏差分析
（如有偏差，列出并说明原因）

### 决策
- [ ] ✅ 通过，进入 Phase 2
- [ ] ⚠️ 有偏差，需要补全
- [ ] ❌ 严重偏离，重新规划

用户确认后继续...
```

### 验收标准（必须全部满足）

1. ✅ **问题识别完整**：列出所有需要重构的问题
2. ✅ **问题分类清晰**：按类型（复杂度、可读性、可维护性、性能等）分类
3. ✅ **重构范围明确**：哪些文件/模块需要重构
4. ✅ **优先级排序**：根据影响和紧急程度排序
5. ✅ **风险评估**：重构可能带来的风险和应对措施
6. ✅ **测试策略**：如何确保重构不破坏现有功能

### 重构问题分类

| 类型 | 描述 | 示例 |
|------|------|------|
| **复杂度** | 圈复杂度过高 | 嵌套过深、分支过多 |
| **可读性** | 代码难以理解 | 命名不清、逻辑混乱 |
| **可维护性** | 修改困难 | 耦合度高、职责不清 |
| **重复代码** | 相同逻辑多处出现 | 复制粘贴代码 |
| **设计问题** | 违反设计原则 | 违反 SOLID、DRY |
| **性能** | 性能瓶颈 | 算法低效、内存泄漏 |

---

## Phase 2: 重构执行

### Step 1: 识别架构

```
请选择重构目标的架构：

1. Java 后端       (DDD 分层架构)
2. iOS 移动端      (MVVM 分层架构)
3. Vue 前端        (Vue 3 分层架构)
4. 其他            (请说明)

请输入数字或架构名称：
```

### Step 2: 调用 Planner

```
📋 Phase 2: 重构执行 - 规划

请调用 planner，基于 Phase 1 的规划规划本阶段：

规划要求：
1. 分析重构计划，设计重构步骤
2. 拆解为原子任务（每次小步重构，保持测试通过）
3. 定义每个任务的验收标准
4. 标记关键检查点
5. 预估执行时间

输出格式参见 /dev 命令中的 "Planner 输出格式"
```

### 重构原则（必须遵守）

1. **小步重构**：每次只改一小部分，立即验证
2. **测试保护**：重构前后测试必须通过
3. **行为不变**：重构不改变外部可见行为
4. **可回滚**：每个步骤都可独立回滚

### Step 3: 执行 Agent

根据选择的架构，调用对应的 Agent：

#### Java 后端
- **Agent**: `agents/java-expert/AGENT.md`
- **Skill**: `skills/for-java-expert/SKILL.md`

#### iOS 移动端
- **Agent**: `agents/ios-expert/AGENT.md`
- **Skill**: `skills/for-ios-expert/SKILL.md`

#### Vue 前端
- **Agent**: `agents/frontend-expert/AGENT.md`
- **Skill**: `skills/for-frontend-expert/SKILL.md`

### Step 4: Checkpoint 验收

```
📋 Phase 2 Checkpoint

### 规划回顾
- 规划步骤数: {总数}
- 已完成: {数量} ✅

### 逐项验收
- [ ] 重构步骤已执行
- [ ] 单元测试通过（重构前后对比）
- [ ] 集成测试通过
- [ ] E2E 测试通过
- [ ] 代码复杂度降低（可测量）
- [ ] 无行为变化（验证）
- [ ] 重构记录已生成

### 偏差分析
（如有偏差，列出并说明原因）

### 决策
- [ ] ✅ 通过，进入 Phase 3
- [ ] ⚠️ 有偏差，需要补全
- [ ] ❌ 严重偏离，重新规划

用户确认后继续...
```

### 验收标准（必须全部满足）

1. ✅ **所有测试通过**：重构前后测试结果一致
2. ✅ **复杂度降低**：圈复杂度、认知复杂度有可测量的下降
3. ✅ **行为不变**：外部可见行为无变化
4. ✅ **代码质量提升**：可读性、可维护性改善
5. ✅ **无新问题**：不引入新的代码问题

### 重构技巧（参考）

| 技巧 | 描述 | 适用场景 |
|------|------|----------|
| **提取方法** | 将一段代码提取为独立方法 | 方法过长、重复代码 |
| **提取类** | 将相关功能提取到新类 | 职责不清、类过大 |
| **内联方法** | 将简单方法内联到调用处 | 方法过度拆分 |
| **引入参数对象** | 将多个参数组合成对象 | 参数过多 |
| **替换算法** | 用更清晰的算法替换 | 算法难以理解 |
| **拆分循环** | 将一个循环拆分为多个 | 循环逻辑复杂 |
| **提炼接口** | 从实现中提炼接口 | 需要解耦 |

---

## Phase 3: 验证与审查

### Step 1: 调用 Planner

```
📋 Phase 3: 验证与审查 - 规划

请调用 planner，规划本阶段的执行步骤：

规划要求：
1. 设计验证策略（功能、性能、安全）
2. 拆解为原子任务
3. 定义每个任务的验收标准
4. 标记关键检查点
5. 预估执行时间

输出格式参见 /dev 命令中的 "Planner 输出格式"
```

### Step 2: 执行 Agent

- **Agent**: `agents/code-reviewer/AGENT.md`（或项目中的 review agent）
- **Skill**: `skills/for-code-reviewer/SKILL.md`（如果有）
- **核心任务**:
  1. 功能验证：确保无行为变化
  2. 性能验证：确保无性能退化
  3. 安全审查：确保不引入安全问题
  4. 代码质量：验证代码质量提升

### Step 3: Checkpoint 验收

```
📋 Phase 3 Checkpoint

### 规划回顾
- 规划步骤数: {总数}
- 已完成: {数量} ✅

### 逐项验收
- [ ] 功能验证通过（无行为变化）
- [ ] 性能验证通过（无退化）
- [ ] 安全审查通过（无新风险）
- [ ] 代码质量提升（可测量）
- [ ] 代码复杂度降低（对比数据）
- [ ] 审查报告已生成

### 偏差分析
（如有偏差，列出并说明原因）

### 决策
- [ ] ✅ 通过，重构完成
- [ ] ⚠️ 有偏差，需要补全
- [ ] ❌ 严重偏离，重新规划

用户确认后完成...
```

### 验收标准（必须全部满足）

1. ✅ **功能验证**：重构前后功能完全一致
2. ✅ **性能验证**：关键性能指标无下降
3. ✅ **安全审查**：不引入新的安全漏洞
4. ✅ **代码质量**：可测量的质量提升
5. ✅ **复杂度对比**：提供重构前后的复杂度数据

### 质量度量指标

| 指标 | 重构前 | 重构后 | 改善 |
|------|--------|--------|------|
| 圈复杂度 | {值} | {值} | {百分比} |
| 认知复杂度 | {值} | {值} | {百分比} |
| 代码行数 | {值} | {值} | {百分比} |
| 重复代码 | {值} | {值} | {百分比} |
| 测试覆盖率 | {值} | {值} | {百分比} |

---

## 完成总结

所有 Phase 完成后，输出：

```
🎉 重构完成！

## 执行摘要
- 重构目标: {描述}
- 重构范围: {范围}
- 总执行时间: {时间}

## 各阶段摘要
- Phase 1 (规划): {完成度} - 识别问题: {数量}
- Phase 2 (执行): {完成度} - 重构步骤: {数量}
- Phase 3 (验证): {完成度} - 验证通过: {全部}

## 重构详情
- 修改文件: {列表}
- 重构类型: {类型}
- 删除代码: {行数}
- 新增代码: {行数}
- 净变化: {行数}

## 质量改善

### 复杂度降低
- 圈复杂度: {重构前} → {重构后} ({改善百分比})
- 认知复杂度: {重构前} → {重构后} ({改善百分比})

### 代码质量提升
- 重复代码: {重构前} → {重构后} ({改善百分比})
- 可读性评分: {重构前} → {重构后}
- 可维护性评分: {重构前} → {重构后}

### 测试覆盖
- 测试覆盖率: {重构前} → {重构后}
- 测试通过率: {百分比}

## 验证结果
- 功能验证: ✅ 无行为变化
- 性能验证: ✅ 无性能退化
- 安全审查: ✅ 无新风险

## 下一步建议
- [ ] 代码审查（/dev review）
- [ ] 创建 PR（/dev pr）
- [ ] 部署验证
- [ ] 监控观察
```

## 特殊场景处理

### 场景 1: 重构过程中发现 Bug

如果在 Phase 2 执行时发现 Bug：

1. 停止重构
2. 创建 Bug 单
3. 评估 Bug 优先级：
   - 如果是严重 Bug，先修复 Bug，再继续重构
   - 如果是次要 Bug，记录下来，重构完成后处理

### 场景 2: 重构导致测试失败

如果在 Phase 2 执行时测试失败：

1. 分析失败原因：
   - 如果是重构引入的问题，回滚重构步骤，重新设计
   - 如果是测试本身的问题，修复测试
2. 确保所有测试通过后才能继续下一步

### 场景 3: 重构范围超出预期

如果在 Phase 1 发现重构范围很大：

1. 评估是否应该分阶段重构
2. 按优先级排序，分批重构
3. 每批重构都是完整的闭环（规划 → 执行 → 验证）

## 常见问题

### Q: 重构和功能开发可以一起做吗？
**A:** 不建议。重构和功能开发应该分开：
- 重构：改变内部结构，不改变外部行为
- 功能开发：改变外部行为，添加新功能
- 混在一起做会增加风险，难以验证

### Q: 重构需要写测试吗？
**A:** 重构前必须有测试保护：
- 如果已有测试，确保测试充分
- 如果没有测试，先补充测试（/dev test）
- 重构必须在测试保护下进行

### Q: 重构花了很长时间怎么办？
**A:**
- 检查是否重构范围过大
- 考虑分阶段重构
- 评估投入产出比，确保重构价值

### Q: 重构后性能下降了怎么办？
**A:**
- 在 Phase 3 的性能测试中发现
- 分析性能下降原因
- 如果是重构引入的，回滚或调整重构方案
- 如果是测试误差，重新测试确认
