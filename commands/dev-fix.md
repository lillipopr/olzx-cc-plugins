---
name: dev-fix
description: Bug 修复流程，用例补充 → 推导修复 → 验证，每个阶段强制 planner 控制
---

# /dev-fix - Bug 修复流程

## 功能

启动 Bug 修复流程，**严格的多阶段规划控制**：使用 TDD 方法，先补充用例，再推导修复，最后验证。

## 使用方式

```
/dev-fix
/dev-fix {Bug 描述}
```

## 完整流程

```
┌─────────────────────────────────────────────────────────────┐
│ Phase 1: Bug 分析与用例补充                                 │
│   planner → tdd-expert → checkpoint                         │
├─────────────────────────────────────────────────────────────┤
│ Phase 2: 修复推导                                           │
│   planner → {domain/Java/iOS/frontend}-expert → checkpoint  │
├─────────────────────────────────────────────────────────────┤
│ Phase 3: 验证与测试                                         │
│   planner → tdd-expert → checkpoint                         │
└─────────────────────────────────────────────────────────────┘
```

## 启动提示

```
🐛 启动 Bug 修复流程

将按以下流程执行：
1. Phase 1: Bug 分析与用例补充
2. Phase 2: 修复推导
3. Phase 3: 验证与测试

⚠️  严格的多阶段规划控制：
   - 每个 Phase 开始前强制使用 planner 拆解任务
   - 每个 Phase 执行后强制 checkpoint 验收
   - 使用 TDD 方法：先写测试，再修复

请描述您要修复的 Bug：
```

---

## Phase 1: Bug 分析与用例补充

### Step 1: 调用 Planner

```
📋 Phase 1: Bug 分析与用例补充 - 规划

请调用 planner，规划本阶段的执行步骤：

规划要求：
1. 分析 Bug 描述，识别根因
2. 拆解为原子任务（问题定位、用例补充、影响范围分析等）
3. 定义每个任务的验收标准
4. 标记关键检查点
5. 预估执行时间

输出格式参见 /dev 命令中的 "Planner 输出格式"
```

### Step 2: 执行 Agent

- **Agent**: `agents/tdd-expert/AGENT.md`
- **Skill**: `skills/for-tdd-expert/SKILL.md`
- **核心任务**:
  1. 问题定位：找出 Bug 的根本原因
  2. 用例补充：为该 Bug 编写失败的测试用例
  3. 影响范围：分析该 Bug 可能影响的其他功能

### Step 3: Checkpoint 验收

```
📋 Phase 1 Checkpoint

### 规划回顾
- 规划步骤数: {总数}
- 已完成: {数量} ✅

### 逐项验收
- [ ] Bug 根因已定位
- [ ] 失败的测试用例已编写
- [ ] 测试用例运行失败（确认 Bug 存在）
- [ ] 影响范围已分析
- [ ] 用例补充文档已生成

### 偏差分析
（如有偏差，列出并说明原因）

### 决策
- [ ] ✅ 通过，进入 Phase 2
- [ ] ⚠️ 有偏差，需要补全
- [ ] ❌ 严重偏离，重新规划

用户确认后继续...
```

### 验收标准（必须全部满足）

1. ✅ **Bug 根因明确**：定位到具体代码位置和原因
2. ✅ **失败测试用例**：编写能够复现 Bug 的测试用例
3. ✅ **测试运行失败**：执行测试，确认失败（RED 阶段）
4. ✅ **影响范围分析**：该 Bug 是否影响其他功能
5. ✅ **最小修复原则**：明确最小修改范围

### TDD 要求

**RED 阶段（本阶段）**：
- 编写失败的测试用例
- 运行测试，确认失败
- 失败原因是预期的 Bug

---

## Phase 2: 修复推导

### Step 1: 识别架构

```
请选择 Bug 所在的架构：

1. Java 后端       (DDD 分层架构)
2. iOS 移动端      (MVVM 分层架构)
3. Vue 前端        (Vue 3 分层架构)
4. 其他            (请说明)

请输入数字或架构名称：
```

### Step 2: 调用 Planner

```
📋 Phase 2: 修复推导 - 规划

请调用 planner，基于 Phase 1 的分析规划本阶段：

规划要求：
1. 分析 Bug 根因，设计修复方案
2. 拆解为原子任务（代码修改、不变量检查等）
3. 定义每个任务的验收标准
4. 标记关键检查点
5. 预估执行时间

输出格式参见 /dev 命令中的 "Planner 输出格式"
```

### Step 3: 执行 Agent

根据选择的架构，调用对应的 Agent：

#### Java 后端
- **Agent**: `agents/java-expert/AGENT.md`
- **Skill**: `skills/for-java-expert/SKILL.md`

#### iOS 移动端
- **Agent**: `agents/ios-expert/AGENT.md`
- **Skill**: `skills/for-ios-expert/SKILL.md`

#### Vue 前端
- **Agent**: `agents/frontend-expert/AGENT.md`
- **Skill**: `skills/for-frontend-expert/SKILL.md`

#### 其他
- 通用流程 + 领域专家

### Step 4: Checkpoint 验收

```
📋 Phase 2 Checkpoint

### 规划回顾
- 规划步骤数: {总数}
- 已完成: {数量} ✅

### 逐项验收
- [ ] 修复方案已设计
- [ ] 代码修改已完成
- [ ] 不变量已检查
- [ ] 边界情况已考虑
- [ ] 修复说明文档已生成

### 偏差分析
（如有偏差，列出并说明原因）

### 决策
- [ ] ✅ 通过，进入 Phase 3
- [ ] ⚠️ 有偏差，需要补全
- [ ] ❌ 严重偏离，重新规划

用户确认后继续...
```

### 验收标准（必须全部满足）

1. ✅ **修复方案最小化**：只修改必要的代码
2. ✅ **保持不变量**：修复不破坏业务不变量
3. ✅ **边界情况覆盖**：考虑修复可能带来的边界问题
4. ✅ **向后兼容**：如果是公共 API，确保兼容性
5. ✅ **代码质量**：遵循设计原则，不引入新问题

### TDD 要求

**GREEN 阶段（本阶段）**：
- 编写最小修复代码
- 运行测试，确认通过
- 不引入新功能

---

## Phase 3: 验证与测试

### Step 1: 调用 Planner

```
📋 Phase 3: 验证与测试 - 规划

请调用 planner，规划本阶段的执行步骤：

规划要求：
1. 设计测试策略（单元、集成、E2E）
2. 拆解为原子任务
3. 定义每个任务的验收标准
4. 标记关键检查点
5. 预估执行时间

输出格式参见 /dev 命令中的 "Planner 输出格式"
```

### Step 2: 执行 Agent

- **Agent**: `agents/tdd-expert/AGENT.md`
- **Skill**: `skills/for-tdd-expert/SKILL.md`
- **核心任务**:
  1. 单元测试：验证修复本身
  2. 集成测试：验证与其他模块的交互
  3. E2E 测试：验证端到端业务流程
  4. 回归测试：确保没有破坏现有功能

### Step 3: Checkpoint 验收

```
📋 Phase 3 Checkpoint

### 规划回顾
- 规划步骤数: {总数}
- 已完成: {数量} ✅

### 逐项验收
- [ ] 单元测试通过
- [ ] 集成测试通过
- [ ] E2E 测试通过
- [ ] 回归测试通过
- [ ] 测试覆盖率 80%+
- [ ] 性能无退化
- [ ] 安全审查通过（如涉及）
- [ ] 测试报告已生成

### 偏差分析
（如有偏差，列出并说明原因）

### 决策
- [ ] ✅ 通过，Bug 修复完成
- [ ] ⚠️ 有偏差，需要补全
- [ ] ❌ 严重偏离，重新规划

用户确认后完成...
```

### 验收标准（必须全部满足）

1. ✅ **所有测试通过**：单元、集成、E2E、回归
2. ✅ **测试覆盖率**：修复代码覆盖率 80% 以上
3. ✅ **无性能退化**：关键性能指标无下降
4. ✅ **无安全风险**：不引入新的安全漏洞
5. ✅ **回归测试通过**：现有功能不受影响

### TDD 要求

**REFACTOR 阶段（本阶段）**：
- 确保所有测试通过
- 如果需要重构，在测试保护下进行
- 重构后测试仍然通过

---

## 完成总结

所有 Phase 完成后，输出：

```
🎉 Bug 修复完成！

## 执行摘要
- Bug 描述: {描述}
- 根因分析: {根因}
- 修复方案: {方案}
- 总执行时间: {时间}

## 各阶段摘要
- Phase 1 (分析): {完成度} - 用例补充: {数量}
- Phase 2 (修复): {完成度} - 代码变更: {文件数}
- Phase 3 (验证): {完成度} - 测试通过率: {百分比}

## 修复详情
- 修改文件: {列表}
- 新增测试: {数量}
- 测试覆盖率: {百分比}
- 影响范围: {范围}

## 验证结果
- 单元测试: ✅ {数量}/{数量}
- 集成测试: ✅ {数量}/{数量}
- E2E 测试: ✅ {数量}/{数量}
- 回归测试: ✅ {数量}/{数量}

## 下一步建议
- [ ] 代码审查（/dev review）
- [ ] 安全审查（/dev security）
- [ ] 创建 PR（/dev pr）
- [ ] 部署验证
```

## 特殊场景处理

### 场景 1: Bug 修复导致新问题

如果在 Phase 3 发现新问题：

1. 记录新问题
2. 评估是否需要重新规划 Phase 2
3. 如果是严重问题，返回 Phase 2
4. 如果是次要问题，可以创建新的 Bug 单

### 场景 2: 影响范围比预期大

如果在 Phase 1 发现影响范围很大：

1. 评估是否应该改为功能迭代（/dev iter）
2. 如果确实是 Bug 但影响大，可能需要：
   - 分阶段修复
   - 创建临时规避方案
   - 更详细的回归测试

### 场景 3: 无法复现 Bug

如果在 Phase 1 无法复现 Bug：

1. 收集更多信息：
   - 环境信息（版本、配置）
   - 复现步骤
   - 日志和错误信息
2. 尝试不同的测试场景
3. 如果确实无法复现，标记为 "无法复现"，建议关闭

## 常见问题

### Q: 必须使用 TDD 吗？
**A:** 强烈建议。TDD 可以确保：
- Bug 真的被修复（测试通过）
- 修复不会回退（测试作为回归）
- 理解问题更深入（写测试的过程就是理解问题的过程）

### Q: 修复过程中发现更多 Bug 怎么办？
**A:**
- 如果是相关的 Bug，可以一并修复（需要在规划中说明）
- 如果是独立的 Bug，建议创建新的 Bug 单，分批处理

### Q: 修复后性能下降了怎么办？
**A:**
- 在 Phase 3 的性能测试中发现
- 评估性能下降是否可接受
- 如果不可接受，需要重新设计修复方案，返回 Phase 2
