---
description: 限界上下文相关原则
---

# 限界上下文相关原则

## 概述

限界上下文（Bounded Context）是 DDD 的核心战略概念，定义了特定领域模型的适用范围。

---

## 1. 业务能力分析原则

### 1.1 能力识别原则

**原则**：使用"动词+名词"格式识别业务能力。

```
✅ 好的能力定义
- 管理会员订阅
- 发放点券
- 处理支付

❌ 差的能力定义
- 会员（缺少动词）
- 管理（缺少对象）
- 点击按钮（太具体，是操作不是能力）
```

### 1.2 能力分解原则（MECE）

**原则**：能力分解遵循 MECE 原则（相互独立，完全穷尽）。

| 原则 | 说明 | 示例 |
|------|------|------|
| **相互独立** | 能力之间不重叠 | 会员订阅和点券发放是独立的 |
| **完全穷尽** | 覆盖所有业务 | 能力树覆盖所有功能 |
| **可独立交付** | 一个能力可独立开发和部署 | 会员订阅可独立迭代 |
| **单一职责** | 一个能力只做一件事 | 点券发放不包含会员创建 |

### 1.3 能力分组原则

**原则**：按数据所有权分组能力。

```
按业务领域分组：
- 用户域：用户注册、登录、认证
- 会员域：会员订阅、权益管理
- 支付域：支付、退款、对账

按数据所有权分组：
- 拥有"会员数据"的能力 → 会员域
- 拥有"点券数据"的能力 → 点券域
```

### 1.4 领域类型识别原则

**原则**：根据战略价值区分领域类型。

| 类型 | 特征 | 投入策略 | 示例 |
|------|------|----------|------|
| **核心域** | 竞争力所在，差异化 | 80% 精力 | 定价算法、推荐引擎 |
| **支撑域** | 必要但非差异化 | 够用就好 | 会员系统、通知系统 |
| **通用域** | 可直接采购/外包 | 直接购买 | 支付、短信、存储 |
| **泛化域** | 无特殊规则 | 最小投入 | 日志、监控 |

---

## 2. 限界上下文划分原则

### 2.1 上下文边界原则

**原则**：上下文边界清晰，内部语言一致。

| 原则 | 说明 | 验证问题 |
|------|------|----------|
| **语言一致性** | 上下文内术语统一 | "会员"在这里的含义一致吗？ |
| **数据所有权** | 一个数据只有一个所有者 | "会员数据"归谁所有？ |
| **独立变更** | 可独立修改和部署 | 改这个上下文不影响其他？ |
| **事务边界** | 强一致性在上下文内 | 事务能在这个边界内完成？ |

### 2.2 上下文识别原则

**原则**：从能力组推导限界上下文。

```
业务能力组 → 限界上下文映射

会员管理能力组
├── 会员订阅 → 会员上下文
├── 会员权益 → 会员上下文
└── 会员状态 → 会员上下文

点券系统能力组
├── 点券发放 → 点券上下文
├── 点券消费 → 点券上下文
└── 点券查询 → 点券上下文
```

### 2.3 康威定律应用原则

**原则**：系统架构 = 组织沟通架构。

```
推论：
- 一个能力边界 = 一个团队边界
- 团队间沟通模式 = 系统间集成模式

能力-团队映射表：
| 能力组 | 负责团队 | 团队规模 |
|--------|----------|----------|
| 会员订阅 | 会员组 | 5 人 |
| 点券系统 | 积分组 | 3 人 |
```

---

## 3. 上下文映射原则

### 3.1 映射模式选择原则

**原则**：根据依赖关系选择合适的映射模式。

| 模式 | 符号 | 关系类型 | 适用场景 |
|------|------|----------|----------|
| **O/C** | → | 上游/下游 | 有明确的依赖方向 |
| **D + ACL** | → | 防腐层 | 集成外部系统或遗留系统 |
| **PL** | ⇄ | 发布语言 | 多个上下文需要共享信息 |
| **CF** | ◆ | 共享内核 | 多个上下文有共同的核心概念 |
| **SC** | ⊂ | 独占客户 | 为特定大客户定制功能 |
| **OH** | ○ | 开放主机 | 提供公共服务 |

### 3.2 防腐层使用原则

**原则**：集成外部系统或遗留系统时必须使用防腐层。

```typescript
// ✅ 正确：使用防腐层
class PaymentService {
  async charge(amount: Money): Promise<Payment> {
    const externalResult = await this.gateway.charge(amount)
    return this.acl.toDomain(externalResult)  // 转换为领域模型
  }
}

// ❌ 错误：直接使用外部模型
class PaymentService {
  async charge(amount: Money): Promise<Payment> {
    const response = await this.gateway.charge(amount)
    return new Payment(response.payment_id, response.status_code)  // 直接使用外部模型
  }
}
```

### 3.3 集成方式选择原则

**原则**：根据实时性要求选择集成方式。

| 集成方式 | 适用场景 | 优点 | 缺点 |
|---------|---------|------|------|
| 同步调用 | 需要实时响应 | 实时反馈 | 耦合度高 |
| 异步事件 | 可以异步处理 | 解耦 | 最终一致性 |
| 消息队列 | 解耦和削峰 | 高可靠性 | 复杂度高 |

---

## 4. 上下文命名原则

**原则**：使用"核心领域 + Context"格式命名。

```
✅ 好的命名
- Membership Context（会员上下文）
- Coupon Context（点券上下文）
- Payment Context（支付上下文）

❌ 差的命名
- Member Context（不够明确）
- Coupon Service（是服务不是上下文）
```

---

## 检查清单

限界上下文设计完成前，确认：

- [ ] 所有业务能力已识别，使用"动词+名词"格式
- [ ] 能力分解遵循 MECE 原则
- [ ] 能力分组清晰，组内高内聚，组间低耦合
- [ ] 每个能力都有明确的负责团队
- [ ] 领域类型已标注（核心/支撑/通用/泛化）
- [ ] 上下文边界清晰
- [ ] 上下文内部语言一致
- [ ] 上下文间关系已定义
- [ ] 集成模式已选择
- [ ] 防腐层需求已识别
