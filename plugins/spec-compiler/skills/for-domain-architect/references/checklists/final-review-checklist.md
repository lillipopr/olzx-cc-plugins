# 最终审查清单：DDD 设计全流程

## 使用说明
- **何时使用**：完成所有章节设计后，进行最终审查
- **预计耗时**：15-20 分钟
- **通过标准**：所有核心项检查通过

---

## 核心检查项

### 1. 限界上下文设计审查

#### 业务能力分析
- [ ] 所有业务能力已使用"动词+名词"格式识别
  - 示例：管理会员订阅、发放点券、处理支付
- [ ] 能力定义清晰，不重叠
- [ ] 能力分解遵循 MECE 原则
  - 相互独立：能力之间不重叠
  - 完全穷尽：覆盖所有业务功能
  - 可独立交付：一个能力可独立开发和部署
  - 单一职责：一个能力只做一件事
- [ ] 能力分组合理
  - 按业务领域分组：用户域、会员域、支付域等
  - 按数据所有权分组：拥有相同数据的能力归为一组
- [ ] 每个能力组都有明确的负责团队
- [ ] 团队规模合理（3-7 人）

#### 领域类型识别
- [ ] 所有领域已标注类型
  - 核心域：竞争力所在，差异化（80% 精力）
  - 支撑域：必要但非差异化（够用就好）
  - 通用域：可直接采购/外包（直接购买）
  - 泛化域：无特殊规则（最小投入）
- [ ] 投入策略与类型匹配

#### 上下文划分
- [ ] 上下文边界清晰
  - 验证问题：这个上下文的职责是什么？
- [ ] 上下文内部语言一致
  - 验证问题："会员"在这里的含义一致吗？
- [ ] 数据所有权明确
  - 验证问题："会员数据"归谁所有？
- [ ] 可独立变更
  - 验证问题：改这个上下文不影响其他？
- [ ] 事务边界在上下文内
  - 验证问题：事务能在这个边界内完成？
- [ ] 上下文命名符合规范
  - 格式：核心领域 + Context
  - 示例：Membership Context、Coupon Context

#### 上下文映射
- [ ] 上下文间关系已定义
- [ ] 集成模式已选择
  - O/C（上游/下游）：有明确的依赖方向
  - D + ACL（防腐层）：集成外部系统或遗留系统
  - PL（发布语言）：多个上下文需要共享信息
  - CF（共享内核）：多个上下文有共同的核心概念
  - SC（独占客户）：为特定大客户定制功能
  - OH（开放主机）：提供公共服务
- [ ] 防腐层需求已识别
- [ ] 集成方式根据实时性要求选择
  - 同步调用：需要实时响应
  - 异步事件：可以异步处理
  - 消息队列：解耦和削峰

#### 康威定律应用
- [ ] 能力边界 = 团队边界
- [ ] 团队间沟通模式 = 系统间集成模式

#### 设计成果
- [ ] 画出了上下文映射图
- [ ] 标注了上下文间关系
- [ ] 标注了领域类型
- [ ] 定义了集成方式

---

### 2. 聚合设计审查（含事件发布）

#### 值对象设计
- [ ] 通过四问法识别所有值对象
  - [ ] 只关注属性值吗（不需要 ID）？
  - [ ] 属性相同即可互换吗？
  - [ ] 是不可变的吗（修改即替换）？
  - [ ] 生命周期依附于他人吗？
- [ ] 每个值对象都有属性定义表格
- [ ] 每个值对象都有约束定义
  - 约束 ID 格式：STR-{VO缩写}-XX
  - 包含类型、描述、伪代码、执行时机

#### 实体设计
- [ ] 通过四问法识别所有实体
  - [ ] 有唯一标识吗？
  - [ ] 需要追踪状态变化吗？
  - [ ] 属性变了还是同一个吗？
  - [ ] 需要独立存储/检索吗？
- [ ] 实体已正确分类
  - 聚合根候选（有全局唯一 ID）
  - 子实体（有局部 ID，生命周期依赖聚合根）
- [ ] 每个实体都有属性定义表格
- [ ] 每个实体都有行为定义表格

#### 聚合根识别
- [ ] 通过四问法从实体中识别聚合根
  - [ ] 有全局唯一标识吗？
  - [ ] 负责维护一致性边界吗？
  - [ ] 拥有独立的生命周期吗？
  - [ ] 是外部访问的唯一入口吗？
- [ ] 聚合根与实体正确区分
  - 聚合根：全局唯一 ID、外部可直接访问、独立生命周期、有专门仓储
  - 实体：局部唯一 ID、只能通过聚合根访问、依赖聚合根、无专门仓储

#### 聚合边界确定
- [ ] 聚合边界清晰，符合"小聚合"原则
  - 聚合尽量小，只包含强一致性的对象
- [ ] 聚合根是唯一入口
  - 外部只能通过聚合根访问内部对象
- [ ] 聚合间引用通过 ID
  - 不存储对象引用，只存储 ID
- [ ] 聚合内强一致性已定义
  - 明确不变量描述
- [ ] 已填写聚合清单表格
- [ ] 已定义聚合间引用方式
  - ID 引用（如 Order.userId）
  - 领域事件（如 MembershipActivated → CouponGrant）
  - 值对象（如 Money、Address）

#### 聚合结构设计
- [ ] 对每个聚合识别成员
  - 聚合根（唯一入口）
  - 实体（有 ID，生命周期依赖聚合根）
  - 值对象（不可变，用值判断相等）
- [ ] 已绘制聚合结构图
  - 使用树状结构展示聚合根、实体、值对象的关系
- [ ] 已填写聚合成员表格

#### 聚合根详细设计
- [ ] 每个聚合根都有属性定义表格
- [ ] 每个聚合根都有职责描述
- [ ] 每个聚合根都有唯一标识说明
- [ ] 每个聚合根都有状态定义表格
  - 状态码、状态名称、含义、可转移状态
- [ ] 每个聚合根都有状态转移图
  - 使用 Mermaid stateDiagram-v2 语法
- [ ] 每个聚合根都有核心行为表格
  - 行为名称、参数、返回值、业务规则

#### 行为设计（含事件发布）
- [ ] 聚合根行为已设计
- [ ] 每个行为都包含完整要素
  - [ ] 方法签名
  - [ ] 业务含义
  - [ ] 前置条件
  - [ ] 后置条件
  - [ ] 约束定义
  - [ ] 用例设计
- [ ] 需要发布事件的行为已设计事件发布
  - [ ] 判断是否需要发布事件
    - 状态发生重要变化
    - 需要通知其他上下文
    - 需要触发异步处理
    - 需要审计追踪
  - [ ] 定义事件名称（过去式）
  - [ ] 定义触发时机
  - [ ] 定义携带数据
- [ ] 每个行为都有约束定义表格
  - 约束ID、类型、描述、伪代码、执行时机
  - 约束 ID 格式：STR-{聚合缩写}-XX
- [ ] 每个行为都有用例设计
  - [ ] 正向场景（Case-{聚合缩写}-N1）
  - [ ] 约束违反场景（Case-{聚合缩写}-B1）
  - [ ] 边界场景（Case-{聚合缩写}-E1）

#### 聚合一致性验证
- [ ] 聚合根有全局唯一标识
- [ ] 聚合根是唯一入口
- [ ] 聚合边界清晰，大小合理（1-3 个实体）
- [ ] 聚合内强一致，聚合间最终一致
- [ ] 实体和值对象已正确区分
- [ ] 值对象不可变
- [ ] 实体只能通过聚合根访问
- [ ] 不变量已识别和实现
- [ ] 不变量在聚合根方法中强制
- [ ] 一个事务只修改一个聚合

#### 设计成果
- [ ] 画出了聚合图
- [ ] 标注了聚合根、实体、值对象
- [ ] 标注了聚合间关系

---

### 3. 领域服务设计审查

#### 领域服务识别
- [ ] 所有领域服务已识别
  - 涉及多个聚合的逻辑
  - 不属于特定实体的逻辑
  - 复杂计算逻辑
- [ ] 服务不包含实体的行为
  - 实体行为保留在聚合根中
  - 领域服务只处理跨聚合或无自然归属的逻辑
- [ ] 使用决策树验证每个服务
  - 涉及多个聚合吗？→ 是 → 领域服务
  - 属于某个实体吗？→ 是 → 实体行为
  - 是复杂计算吗？→ 是 → 领域服务

#### 领域服务列表
- [ ] 服务列表包含所有领域服务
  - 服务名称、职责、涉及聚合、优先级
- [ ] 服务命名符合规范
  - 格式：聚合名 + Domain（如 MembershipDomain、CouponDomain）
  - 不使用 XxxService（与 Application 层混淆）
  - 不使用 XxxDomainService（繁琐）

#### 服务详细设计
- [ ] 每个服务都有方法签名
  - 格式：`{方法名}(params: { {参数1}: {类型1} }): {返回类型}`
  - 参数和返回类型明确
- [ ] 每个服务都有职责描述
  - 职责不重叠
- [ ] 每个服务都有约束定义
  - 约束ID格式：BIZ-{服务缩写}-NN
  - 包含类型、描述、伪代码、执行时机
  - 伪代码格式：`ASSERT {条件表达式}`
- [ ] 每个服务都有用例设计
  - 正向场景（N1, N2...）
  - 约束违反场景（B1, B2...）
  - 边界场景（E1, E2...）
  - 用例包含 Given、When、Then、验证约束

#### 服务设计原则验证
- [ ] 服务不修改聚合状态（或协调多个聚合）
  - 无状态：不持有聚合引用
  - 协调：通过调用聚合根行为来修改状态
  - 不直接操作聚合根属性
- [ ] 领域服务正确协作聚合根
  - 业务验证在领域服务
  - 状态修改在聚合根
  - 示例：`from.deductPoints(amount)` 而非 `from.points -= amount`

#### 设计成果
- [ ] 画出了领域服务图
- [ ] 标注了服务类型

---

### 4. 应用层设计审查（含事件处理）

#### 应用层职责
- [ ] 应用层职责清晰
  - 用例编排：协调多个领域对象
  - 事务管理：管理事务边界
  - 调用领域层：调用聚合根和领域服务
  - 发布领域事件：发布聚合根产生的事件
  - 返回结果：返回 DTO 或响应
- [ ] 应用层不包含业务逻辑
  - 业务逻辑在领域层
  - 应用层只负责编排

#### 用户行为 vs 系统行为
- [ ] 用户行为和系统行为已区分
  - 用户行为：用户操作触发、需要权限控制、需要参数校验
  - 系统行为：系统事件触发、无用户交互、无权限控制
- [ ] 使用决策树验证行为分类
  - 由用户发起吗？→ 是 → 用户行为
  - 由事件触发吗？→ 是 → 系统行为
  - 由定时任务触发吗？→ 是 → 系统行为

#### 应用服务设计
- [ ] 应用服务命名符合规范
  - 格式：聚合名 + Application
  - 示例：MembershipApplication、CouponApplication
  - 不使用 XxxService（与领域服务混淆）
  - 不使用 XxxController（Controller 层命名）
- [ ] 应用服务方法命名符合规范
  - 格式：动词+名词，表达用例意图
  - 示例：createMembership()、cancelMembership()、upgradeMembership()
- [ ] 应用服务方法遵循统一结构
  1. 参数校验
  2. 调用领域层
  3. 保存
  4. 发布事件
  5. 返回结果

#### 业务逻辑分层
- [ ] 参数校验分层清晰
  - 应用层：参数校验（格式、必填、范围）
  - 领域层：业务规则校验（业务不变量）

#### 事务管理
- [ ] 应用层管理事务边界
  - 使用 @Transactional 注解
  - 事务不泄漏到领域层
- [ ] 一个事务只修改一个聚合
  - 验证：检查事务代码
  - 多个聚合修改应该分多个事务

#### Command 和 DTO 设计
- [ ] Command 表示用户意图
  - 包含输入参数
  - 不包含业务规则
  - 示例：CreateMembershipCommand
- [ ] DTO 是数据传输对象
  - 只包含数据
  - 不包含业务逻辑
  - 不包含业务方法
  - 示例：MembershipDTO

#### 错误处理
- [ ] 错误分类处理正确
  - 参数错误：HTTP 200，业务状态码 400
  - 权限错误：HTTP 200，业务状态码 403
  - 业务错误：HTTP 200，业务状态码 422
  - 系统错误：HTTP 200，业务状态码 500
- [ ] 领域异常转换为应用层响应
  - BusinessRuleException → 422
  - ValidationException → 400
  - 系统异常向上抛出

#### 事件处理设计（v2.1 新增）
- [ ] 所有领域事件都有对应的监听器
  - 检查：第二章中的事件发布都有监听器
  - 检查：监听器列表完整
- [ ] 监听器职责清晰
  - 监听器所属应用服务明确
  - 监听器影响的聚合明确
  - 监听器处理逻辑清晰
- [ ] 监听器包含完整的处理步骤
  - 事件接收
  - 幂等性检查
  - 参数校验
  - 调用领域服务/聚合
  - 结果处理
- [ ] 监听器有幂等性保证
  - 幂等键定义清晰（eventId）
  - 存储位置明确（Redis/DB）
  - 去重逻辑正确
- [ ] 监听器有完善的异常处理
  - 异常类型分类清晰
  - 处理方式明确（重试/死信队列）
  - 是否重试的判断标准清晰

#### 设计成果
- [ ] 画出了应用层图
- [ ] 标注了用户行为和系统行为
- [ ] 标注了事务边界
- [ ] 标注了错误处理流程
- [ ] 标注了事件监听器

---

### 5. 入口层设计审查

#### 入口层核心原则
- [ ] 入口层仅负责参数校验、调用应用层、返回结果
  - 不包含业务逻辑
  - 业务逻辑在应用层和领域层
- [ ] 所有接口返回统一的响应结构
  ```typescript
  interface ApiResponse<T> {
    code: number          // 业务状态码
    message: string       // 响应消息
    data?: T             // 业务数据
  }
  ```
- [ ] 统一的异常处理和错误码映射
  - 参数校验失败：业务状态码 400
  - 权限不足：业务状态码 403
  - 业务规则违反：业务状态码 422
  - 系统错误：业务状态码 500

#### Controller 层设计
- [ ] Controller 只允许 POST 接口
  - 不使用 GET、PUT、DELETE
  - 原因：POST 语义清晰，统一风格
- [ ] 路径设计符合规范
  - 格式：/api/版本/端/聚合名/动作
  - 全小写：wallet、freeze、login
  - 连字符分隔：daily-grant、expire-check
  - 动词结尾：create、cancel、freeze、login
- [ ] 端标识使用正确
  - m（Mobile）：移动端（iOS/Android App）
  - c（Client）：客户端（通用）
  - w（Web）：网页端（浏览器）
  - a（Admin）：管理端（后台）
- [ ] Controller 命名符合规范
  - 格式：聚合名 + Controller
  - 示例：MembershipController、CouponController、PaymentController
- [ ] 所有 Controller 已识别
- [ ] 所有接口都有请求定义
- [ ] 所有接口都有响应定义
- [ ] 所有接口都有异常处理
- [ ] 响应格式统一

#### 请求参数设计
- [ ] 参数命名符合规范
  - 格式：{动作} + {聚合名} + Param
  - 示例：CreateMembershipParam、FreezeWalletParam、CancelOrderParam
- [ ] 不使用原始数据类型
  - 不直接使用 string、number、boolean
  - 所有参数必须是对象类型
- [ ] 使用 Request Body 传递参数
  - 不使用 URL 参数
  - 不使用多个原始类型参数
- [ ] 参数对象只包含输入字段
  - 不包含业务规则
  - 不包含派生字段

#### MQ 层设计
- [ ] 消费者只负责接收消息、调用应用层、确认消息
  - 不包含业务逻辑
  - 业务逻辑在应用层
- [ ] 消费者保证幂等性
  - 使用 eventId 作为幂等键
  - 处理前检查是否已处理
- [ ] 消费者异常处理正确
  - 参数错误：发送到死信队列，告警，不重试
  - 业务错误：发送到死信队列，告警，不重试
  - 系统错误：重新入队（最多 N 次），重试
  - 超过重试次数：发送到死信队列，告警，不重试
- [ ] 所有消费者已识别
- [ ] 每个消费者都有消息定义
- [ ] 每个消费者都有处理逻辑

#### Task 层设计
- [ ] 定时任务只负责触发、调用应用层、记录日志
  - 不包含业务逻辑
  - 业务逻辑在应用层
- [ ] 定时任务使用分布式锁
  - 获取锁：执行任务
  - 获取失败：跳过本次执行
  - 锁超时：设置合理的超时时间
- [ ] 定时任务有监控指标
  - 执行耗时：> 30 秒告警
  - 失败次数：> 3 次/天告警
  - 跳过次数：> 10 次/天告警
- [ ] 所有任务已识别
- [ ] 每个任务都有调度策略
- [ ] 每个任务都有执行逻辑
- [ ] 每个任务都有分布式锁
- [ ] 每个任务都有异常处理
- [ ] 每个任务都有监控指标

#### 数据模型转换
- [ ] 入口层使用 DTO，不直接使用领域模型
  - Request → Command
  - Domain → DTO
  - 不直接暴露领域模型
- [ ] 参数校验分层清晰
  - 入口层：格式校验（邮箱格式、手机号格式）
  - 入口层：参数校验（必填字段、数值范围）
  - 领域层：业务规则校验（会员只能有一个生效订阅）

#### 接口文档
- [ ] 每个接口有完整的文档
  - 接口名称：清晰的接口名称
  - 接口描述：接口的业务含义
  - 请求定义：Request Header、Request Body
  - 响应定义：成功响应、失败响应
  - 请求示例：JSON 示例
  - 响应示例：JSON 示例
  - 错误码：所有可能的错误码
- [ ] 接口使用路径版本控制
  - 格式：/api/v1/、/api/v2/
  - 不使用查询参数版本控制

#### 设计成果
- [ ] 画出了接口图
- [ ] 标注了接口路径和参数

---

### 6. 架构一致性审查

#### 依赖方向
- [ ] 依赖方向正确
  - View → ViewModel → Service → Gateway → Network（iOS）
  - Controller → Application → Domain ← Gateway/Infra（Java）
  - View → Composable → Service → API → Request（Vue）

#### 分层清晰
- [ ] 分层清晰，职责明确
- [ ] 上层依赖下层，下层不依赖上层
- [ ] 依赖倒置正确

#### 命名规范
- [ ] 命名符合各层规范
- [ ] 命名统一，不混淆

---

### 7. 设计原则一致性

#### SOLID 原则
- [ ] 单一职责原则：每个类只有一个职责
- [ ] 里氏替换原则：子类可以替换父类
- [ ] 依赖倒置原则：依赖抽象而非具体
- [ ] 接口隔离原则：接口小而专注
- [ ] 开闭原则：对扩展开放，对修改关闭

#### DDD 原则
- [ ] 聚合尽可能小
- [ ] 聚合内强一致，聚合间最终一致
- [ ] 领域层不依赖任何其他层
- [ ] 应用层编排，领域层执行
- [ ] 入口层薄，不包含业务逻辑

---

## 快速验证

### 数量指标
- [ ] 限界上下文：3-8 个
- [ ] 聚合根：每个上下文 2-5 个
- [ ] 领域服务：每个上下文 2-5 个
- [ ] 应用服务：每个聚合 3-8 个方法
- [ ] 接口：每个聚合 3-8 个

### 质量指标
- [ ] 聚合大小：1-3 个实体，深度 1-2 层
- [ ] 事务粒度：一个事务一个聚合
- [ ] 业务逻辑：应用层无业务逻辑
- [ ] 接口方法：100% POST
- [ ] 参数类型：100% 使用 Param 对象
- [ ] 响应格式：100% 统一响应格式

### 文档完整性
- [ ] 上下文映射图
- [ ] 聚合图
- [ ] 领域服务图
- [ ] 应用层图
- [ ] 接口图

---

## 常见问题

**Q: 最终审查的目的是什么？**
A: 确保所有章节的设计一致，符合 DDD 原则，没有遗漏或冲突。

**Q: 如何验证设计的一致性？**
A: 检查依赖方向、分层清晰度、命名规范、设计原则的一致性。

**Q: 如果发现不一致怎么办？**
A: 回到相关章节，根据原则进行调整，确保整体设计一致。

**Q: 事件发布和事件处理分别在哪一章设计？**
A: v2.1 后，事件发布整合到第二章（聚合设计）的聚合根行为中，事件处理整合到第四章（应用层设计）的事件监听器中。

**Q: 为什么没有独立的领域事件审查？**
A: v2.1 更新删除了独立的领域事件章节，事件设计已整合到聚合设计和应用层设计中。

**Q: 最终审查需要多长时间？**
A: 通常 15-20 分钟，取决于设计的复杂度。

**Q: 最终审查通过后可以做什么？**
A: 可以开始编写代码，或者进行详细设计（如数据库设计、接口设计）。

---

## 原则追溯

本检查清单基于所有章节的原则：
- `chapter-01-bounded-context.md`：限界上下文相关原则
- `chapter-02-aggregate.md`：聚合相关原则（含事件发布设计）
- `chapter-03-domain-service.md`：领域服务相关原则
- `chapter-04-application.md`：应用层相关原则（含事件处理设计）
- `chapter-05-starter.md`：入口层相关原则

---

## 审查通过标准

所有核心检查项（[ ]）都通过，即视为最终审查通过。

### 通过标准
- **及格线**：所有核心检查项 80% 以上通过
- **优秀线**：所有核心检查项 95% 以上通过

### 通过后可以
1. 开始编写代码
2. 进行详细设计
3. 编写技术文档

### 未通过需要
1. 回到相关章节
2. 根据原则调整设计
3. 重新进行最终审查
