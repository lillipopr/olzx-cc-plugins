# 第二章检查清单：聚合设计

## 使用说明
- **何时使用**：完成第二章（聚合设计）后
- **预计耗时**：10-15 分钟
- **通过标准**：所有核心项检查通过

---

## 核心检查项

### 1. 值对象设计（Step 1）

#### 值对象识别（四问法）
- [ ] 通过四问法识别所有值对象
  - [ ] 只关注属性值吗（不需要 ID）？
  - [ ] 属性相同即可互换吗？
  - [ ] 是不可变的吗（修改即替换）？
  - [ ] 生命周期依附于他人吗？

#### 值对象设计
- [ ] 每个值对象都有属性定义表格
- [ ] 每个值对象都有约束定义
  - 约束 ID 格式：STR-{VO缩写}-XX
  - 包含类型、描述、伪代码、执行时机

---

### 2. 实体设计（Step 2）

#### 实体识别（四问法）
- [ ] 通过四问法识别所有实体
  - [ ] 有唯一标识吗？
  - [ ] 需要追踪状态变化吗？
  - [ ] 属性变了还是同一个吗？
  - [ ] 需要独立存储/检索吗？

#### 实体分类
- [ ] 实体已正确分类
  - 聚合根候选（有全局唯一 ID）
  - 子实体（有局部 ID，生命周期依赖聚合根）

#### 实体设计
- [ ] 每个实体都有属性定义表格
- [ ] 每个实体都有行为定义表格

---

### 3. 聚合根识别（Step 3）

#### 聚合根识别（四问法）
- [ ] 通过四问法从实体中识别聚合根
  - [ ] 有全局唯一标识吗？
  - [ ] 负责维护一致性边界吗？
  - [ ] 拥有独立的生命周期吗？
  - [ ] 是外部访问的唯一入口吗？

#### 聚合根 vs 实体区分
- [ ] 聚合根与实体正确区分
  - 聚合根：全局唯一 ID、外部可直接访问、独立生命周期、有专门仓储
  - 实体：局部唯一 ID、只能通过聚合根访问、依赖聚合根、无专门仓储

---

### 4. 聚合边界确定（Step 4）

#### 聚合边界原则
- [ ] 聚合边界清晰，符合"小聚合"原则
  - 聚合尽量小，只包含强一致性的对象
- [ ] 聚合根是唯一入口
  - 外部只能通过聚合根访问内部对象
- [ ] 聚合间引用通过 ID
  - 不存储对象引用，只存储 ID
- [ ] 聚合内强一致性已定义
  - 明确不变量描述

#### 聚合清单
- [ ] 已填写聚合清单表格
  - 聚合名称、聚合根、聚合边界、一致性保证

#### 聚合间引用
- [ ] 已定义聚合间引用方式
  - ID 引用（如 Order.userId）
  - 领域事件（如 MembershipActivated → CouponGrant）
  - 值对象（如 Money、Address）

---

### 5. 聚合结构设计（Step 5）

#### 聚合成员识别
- [ ] 对每个聚合识别成员
  - 聚合根（唯一入口）
  - 实体（有 ID，生命周期依赖聚合根）
  - 值对象（不可变，用值判断相等）

#### 聚合结构图
- [ ] 已绘制聚合结构图
  - 使用树状结构展示聚合根、实体、值对象的关系

#### 聚合成员表格
- [ ] 已填写聚合成员表格
  - 成员名称、类型、说明

---

### 6. 聚合根详细设计（Step 6）

#### 聚合根属性
- [ ] 每个聚合根都有属性定义表格
- [ ] 每个聚合根都有职责描述
- [ ] 每个聚合根都有唯一标识说明

#### 状态定义
- [ ] 每个聚合根都有状态定义表格
  - 状态码、状态名称、含义、可转移状态
- [ ] 每个聚合根都有状态转移图
  - 使用 Mermaid stateDiagram-v2 语法

#### 核心行为
- [ ] 每个聚合根都有核心行为表格
  - 行为名称、参数、返回值、业务规则

---

### 7. 行为设计（Step 7）

#### 行为设计完整性
- [ ] 聚合根行为已设计
- [ ] 每个行为都包含以下要素：
  - [ ] 方法签名
  - [ ] 业务含义
  - [ ] 前置条件
  - [ ] 后置条件
  - [ ] 约束定义
  - [ ] 用例设计

#### 事件发布设计（v2.1 新增）
- [ ] 需要发布事件的行为已设计事件发布
  - [ ] 判断是否需要发布事件
    - 状态发生重要变化
    - 需要通知其他上下文
    - 需要触发异步处理
    - 需要审计追踪
  - [ ] 定义事件名称（过去式）
  - [ ] 定义触发时机
  - [ ] 定义携带数据

#### 约束定义
- [ ] 每个行为都有约束定义表格
  - 约束ID、类型、描述、伪代码、执行时机
  - 约束 ID 格式：STR-{聚合缩写}-XX
- [ ] 所有约束都有 ID 和伪代码

#### 用例设计
- [ ] 每个行为都有用例设计
  - [ ] 正向场景（Case-{聚合缩写}-N1）
  - [ ] 约束违反场景（Case-{聚合缩写}-B1）
  - [ ] 边界场景（Case-{聚合缩写}-E1）

---

## 输出格式检查

### 1. 聚合总览
- [ ] 已填写聚合清单
- [ ] 已绘制聚合间关系图
- [ ] 已填写聚合间引用表

### 2. 单个聚合详细设计
- [ ] 每个聚合都有聚合结构说明
- [ ] 每个聚合根都有详细设计
- [ ] 每个实体都有详细设计
- [ ] 每个值对象都有详细设计
- [ ] 每个行为都有详细设计

---

## 快速验证指标

- [ ] 值对象识别完整度：所有可复用概念都识别为值对象
- [ ] 实体识别准确度：有 ID 的对象正确识别为实体
- [ ] 聚合根识别准确度：全局唯一 ID 的实体正确识别为聚合根
- [ ] 聚合边界合理性：聚合尽可能小，只包含强一致性对象
- [ ] 状态机设计完整性：有状态的聚合根都设计了状态转移图
- [ ] 事件设计完整性：需要事件的行为都设计了事件发布
- [ ] 约束定义完整性：所有行为都有约束定义
- [ ] 用例设计完整性：所有行为都有用例设计（正向、违反、边界）

---

## 常见问题

**Q: 为什么先设计值对象？**
A: 值对象是最简单的领域元素，没有 ID，不可变。先识别值对象可以避免将本应是值对象的元素错误设计为实体。

**Q: 实体和值对象的区别？**
A: 实体有 ID、可变、用 ID 判断相等；值对象无 ID、不可变、用值判断相等。

**Q: 聚合根和实体的区别？**
A: 聚合根有全局唯一 ID、可独立访问、有独立生命周期、有专门仓储；实体只有局部 ID、只能通过聚合根访问、依赖聚合根。

**Q: 聚合边界如何确定？**
A: 原则包括：聚合尽量小、聚合根是唯一入口、引用通过 ID、强一致性边界。

**Q: 什么时候需要发布事件？**
A: 状态发生重要变化、需要通知其他上下文、需要触发异步处理、需要审计追踪时。事件发布必须在状态变更成功后。

---

## 原则追溯

本检查清单基于第二章章节指令：
- Step 1：值对象设计（四问法）
- Step 2：实体设计（四问法）
- Step 3：聚合根识别（四问法）
- Step 4：聚合边界确定
- Step 5：聚合结构设计
- Step 6：聚合根详细设计
- Step 7：行为设计（含事件发布）

参考文档：[references/principles/aggregate.md](references/principles/aggregate.md)
