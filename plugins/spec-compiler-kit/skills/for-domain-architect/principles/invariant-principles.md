# 不变量设计原则

> **理论来源**：Bertrand Meyer《面向对象软件构造》Design by Contract 原则

## 核心定义

### 什么是不变量？

不变量（Invariant）= 系统中**永远为真**的约束条件

### 核心特征

| 特征 | 说明 | 示例 |
|------|------|------|
| **永远为真** | 不是 if 判断，不是"一般情况下" | 库存必须 >= 0 |
| **可自动验证** | 能写成 assert 语句 | `assert inventory.quantity >= 0` |
| **不依赖实现** | 与代码细节无关 | 与如何扣减库存的实现无关 |

### 与业务规则的区别

| 类型 | 业务规则 | 不变量 |
|------|---------|--------|
| **性质** | 描述性 | 约束性 |
| **验证** | 人工审核 | 自动化测试 |
| **违反** | 警告 | 系统拒绝 |
| **示例** | "用户应该填写邮箱" | "无邮箱不能创建账号" |

---

## 不变量三测试（极重要）

每个不变量必须通过以下三个测试：

### ✅ 测试 1：可执行

**问题**：能否写成 assert 语句？

#### 业务不变量示例

```python
# 自然语言描述
INV-1: 只有 M1 状态才能发放点券

# 转换为 assert
assert membership.state == "M1" or coupon_grant_amount == 0
```

```python
# 自然语言描述
INV-2: 每天最多发放一次（幂等）

# 转换为 assert
assert count_daily_grants(user_id, date) <= 1
```

#### UI 不变量示例

```swift
// 自然语言描述
UI-INV-01: Loading 状态下提交按钮必须 disabled

// 转换为 assert
assert uiState != .loading || submitDisabled == true
```

### ✅ 测试 2：可测试

**问题**：能否设计用例验证它？

#### 业务不变量用例

```gherkin
Case: 验证 INV-1
Given: 会员状态 = M0
When: 触发刷新点券
Then: 点券增加量 = 0
```

#### UI 不变量用例

```gherkin
Case-UI-01: 加载状态正确显示
Given: 用户进入页面，数据未加载
When: 触发数据加载
Then:
  - UI 状态：UI-0 → UI-1
  - 显示：LoadingView（加载指示器）
  - 交互：提交按钮 disabled
  - 约束：UI-INV-01
```

### ✅ 测试 3：可解释

**问题**：能否用自然语言解释为什么它必须成立？

#### 业务不变量解释

> INV-1 的原因：点券是会员权益，非会员不应获得，否则违反商业规则。

#### UI 不变量解释

> UI-INV-01 的原因：Loading 状态表示异步操作进行中，此时允许用户提交可能导致重复请求或状态混乱。

### ❌ 不合格示例

| 不合格描述 | 问题 | 正确写法 |
|-----------|------|---------|
| "一般情况下用户应该..." | 模糊，无法验证 | "用户必须..." |
| "正常情况下不超过..." | 什么情况算"正常"？ | "始终 ≤ X" |
| "用户不应该..." | 这是期望，不是约束 | "系统拒绝..." |
| "尽量保证..." | 无法自动化验证 | "必须保证..." |

---

## 不变量分类

### 1. 结构约束（STR-）

数据结构完整性约束。

| 约束ID | 约束描述 | 执行时机 |
|-------|---------|---------|
| STR-01 | 订单必须有至少一个订单项 | 创建时 |
| STR-02 | 用户邮箱不能为空 | 创建时 |

### 2. 业务约束（BIZ-）

业务规则正确性约束。

| 约束ID | 约束描述 | 执行时机 |
|-------|---------|---------|
| BIZ-01 | 只有 M1 状态才能发放点券 | 发放时 |
| BIZ-02 | 每个用户每天最多发放一次 | 发放时 |

### 3. 状态约束（STA-）

状态转移合法性约束。

| 约束ID | 约束描述 | 执行时机 |
|-------|---------|---------|
| STA-01 | 只有待支付订单可以取消 | 取消操作时 |
| STA-02 | 已发货订单不能回退 | 状态变更时 |

### 4. 版本约束（VER-）

版本不可变性约束。

| 约束ID | 约束描述 | 执行时机 |
|-------|---------|---------|
| VER-01 | 历史记录不可修改 | 修改操作时 |
| VER-02 | 规则版本必须单调递增 | 版本升级时 |

### 5. 可解释性约束（EXP-）

结果可追溯性约束。

| 约束ID | 约束描述 | 执行时机 |
|-------|---------|---------|
| EXP-01 | 每个标签必须能回溯到指标区间 | 生成报告时 |
| EXP-02 | 报告必须能解释结果来源 | 展示报告时 |

---

## 实体收敛原则

**核心原则**：一个实体 = 一组必须被一起保护的不变量

### 原则说明

不变量是聚合边界的决定因素。如果一组不变量必须被一起保护（在同一事务中），那么它们属于同一个聚合。

### 实体收敛三问

1. 是否承载至少一个不变量？
2. 是否有生命周期？
3. 是否需要被并发保护？

少于 2 个 → 不该是实体（值对象/计算结果）

### 示例

| 不变量 | 依附对象 | 聚合归属 |
|--------|----------|---------|
| INV-01 会员才能发 | 用户会员身份 | 用户聚合 |
| INV-02 每天一次 | 用户 + 日期 | 用户聚合 |
| INV-03 总量 ≤ 100 | 会员账户 | 用户聚合 |

以上三个不变量必须被一起保护，因此都属于**用户聚合**。

---

## 不变量设计原则

### 1. 最小化原则

不变量应该尽可能少，只保留必须的约束。

**反例**：
```
INV-01: 用户名不能为空
INV-02: 用户名长度 2-20 字符
INV-03: 用户名只能包含字母数字
INV-04: 用户名不能包含敏感词
...
```

**正例**：
```
INV-01: 用户名必须符合命名规范（包含非空、长度、字符集、敏感词）
```

### 2. 独立性原则

不变量之间应该相互独立，避免重复定义。

**反例**：
```
INV-01: 订单金额 = 所有订单项金额之和
INV-02: 订单金额 >= 0  # 冗余，由 INV-01 推导
```

**正例**：
```
INV-01: 订单金额 = 所有订单项金额之和
# INV-02 可由 INV-01 推导，无需显式定义
```

### 3. 可验证原则

不变量应该可以在合理的时间内验证完成。

**反例**：
```
INV-01: 全局订单金额总和不能超过预算  # 需要扫描全表
```

**正例**：
```
INV-01: 单个订单金额不能超过 10000  # 可在 O(1) 内验证
```

---

## 不变量与聚合设计

### 不变量决定聚合边界

聚合边界由**必须被一起保护的不变量**决定。

**示例**：订单与订单项

```
不变量：
INV-01: 订单金额 = 所有订单项金额之和
INV-02: 订单项数量 = 订单项列表长度

聚合设计：
订单（聚合根）
├── 订单项（实体）
└── 订单项（实体）

原因：INV-01 和 INV-02 必须在同一事务中验证
```

### 跨聚合不变量

跨聚合的不变量使用**最终一致性**。

**示例**：用户余额与订单金额

```
不变量：
INV-01: 用户余额 >= 订单金额  # 跨聚合

处理方式：
1. 预扣减（应用层）
2. 创建订单（订单聚合）
3. 确认扣减（用户聚合）
4. 补偿机制（如果失败）
```

---

## 不变量执行时机

| 约束类型 | 执行时机 | 执行位置 | 失败处理 |
|---------|---------|---------|---------|
| 结构约束 | 实体创建/更新时 | Domain 层 | 抛出异常 |
| 业务约束 | 业务操作前 | Application 层 | 返回错误 |
| 状态约束 | 状态变更时 | Domain 层 | 抛出异常 |
| 版本约束 | 修改时 | Domain 层 | 抛出异常 |

---

## 不变量与测试

### 单元测试

每个不变量应该有对应的单元测试。

```java
@Test
public void test_INV01_MembershipOnly() {
    // Given
    Membership membership = new Membership();
    membership.setState(M0); // 非会员

    // When
    int granted = membership.grantCoupons(100);

    // Then
    assertEquals(0, granted); // 非会员不能发放
}
```

### 集成测试

不变量在集成测试中验证端到端行为。

```java
@Test
public void test_INV01_EndToEnd() {
    // Given
    User user = createNonMemberUser();

    // When
    Result result = couponService.dailyGrant(user.getId());

    // Then
    assertFalse(result.isSuccess());
    assertEquals("INV-01: 非会员不能发放点券", result.getError());
}
```

---

## 参考来源

| 来源 | 说明 |
|------|------|
| Bertrand Meyer《面向对象软件构造》 | Design by Contract 原则 |
| Eric Evans《领域驱动设计》 | 聚合设计中的不变量 |
| Martin Fowler | 不变量与聚合边界 |
