# 第二章检查清单：聚合设计

## 使用说明
- **何时使用**：完成第二章（聚合设计）后
- **预计耗时**：5-10 分钟
- **通过标准**：所有核心项检查通过

---

## 核心检查项

### 1. 聚合根识别

#### 聚合根判断
- [ ] 通过三问法判断聚合根
  - 有全局唯一标识吗？
  - 有独立生命周期吗？
  - 维护一致性边界吗？
- [ ] 聚合根与实体正确区分
  - 聚合根：全局唯一 ID、外部可直接访问、独立生命周期、有专门仓储
  - 实体：局部唯一 ID、只能通过聚合根访问、依赖聚合根、无专门仓储

#### 聚合根命名
- [ ] 聚合根命名清晰
  - 使用业务语言命名
  - 示例：Order、Membership、Coupon

---

### 2. 聚合边界设计

#### 黄金法则
- [ ] 聚合尽可能小
  - 推荐：1-3 个实体，深度 1-2 层
  - 警告：4-7 个实体，深度 2-3 层（需要评估）
  - 避免：8+ 个实体，深度 3+ 层（需要拆分）

#### 聚合根入口
- [ ] 聚合根是唯一入口
  - 外部只能通过聚合根访问聚合内部对象
  - 不应该有实体的专门仓储

#### 聚合内强一致
- [ ] 聚合内部保证强一致性
  - 验证：聚合内数据必须在同一个事务中修改
- [ ] 不变量在聚合根方法中强制
  - 状态约束：过期订单不能修改
  - 数量约束：订单不能超过 10 个项目
  - 值约束：金额不能为负
  - 引用约束：订单项必须关联有效产品

---

### 3. 聚合间关系

#### 引用方式
- [ ] 聚合间引用只存储 ID
  - 不存储对象引用
  - 示例：Order.userId（只存储 ID）

#### 一致性策略
- [ ] 聚合间接受最终一致性
  - 通过领域事件实现最终一致
  - 不在同一个事务中修改多个聚合

#### 事务边界
- [ ] 一个事务只修改一个聚合
  - 验证：检查应用层事务管理代码

---

### 4. 实体识别

#### 实体判断
- [ ] 通过三条件判断实体
  - 有标识吗？（局部唯一 ID）
  - 可变吗？（属性可以变化）
  - 生命周期依赖聚合根吗？（不能独立存在）

#### 实体设计
- [ ] 实体只能通过聚合根访问
- [ ] 实体没有独立的仓储

---

### 5. 值对象识别

#### 值对象判断
- [ ] 通过三条件判断值对象
  - 无标识吗？（用值判断相等）
  - 不可变吗？（创建后不能修改）
  - 可复用吗？（可在多处使用）

#### 值对象设计
- [ ] 值对象必须不可变
  - 使用 readonly 修饰属性
  - 操作返回新对象，不修改原对象
- [ ] 值对象没有 ID
- [ ] 值对象可独立存在

---

### 6. 聚合设计模式

#### 模式选择
- [ ] 聚合设计模式合理
  - 单实体聚合：只包含聚合根
  - 父子聚合：包含父子关系的实体
  - 聚合引用：通过 ID 引用其他聚合

#### 并发冲突
- [ ] 考虑了并发冲突处理
  - 验证：两个用户同时修改会冲突吗？
  - 策略：乐观锁、悲观锁

---

## 快速验证

### 关键指标
- [ ] 聚合根数量：每个上下文 2-5 个
- [ ] 聚合大小：1-3 个实体，深度 1-2 层
- [ ] 不变量数量：每个聚合 2-5 个
- [ ] 值对象复用：至少 30% 的可复用概念使用值对象

### 设计验证
- [ ] 画出了聚合图
- [ ] 标注了聚合根
- [ ] 标注了实体和值对象
- [ ] 标注了聚合间关系（只通过 ID）

---

## 常见问题

**Q: 如何判断聚合大小是否合理？**
A: 使用黄金法则：让聚合尽可能小。如果一个聚合包含 8+ 个实体或深度 3+ 层，需要拆分。

**Q: 聚合根和实体的区别是什么？**
A: 聚合根有全局唯一 ID、可独立访问、有独立生命周期、有专门仓储；实体只有局部 ID、只能通过聚合根访问、依赖聚合根。

**Q: 值对象和实体的区别是什么？**
A: 值对象无 ID、不可变、用值判断相等；实体有 ID、可变、用 ID 判断相等。

**Q: 为什么一个事务只能修改一个聚合？**
A: 聚合是强一致性边界，聚合间应该通过领域事件实现最终一致性。

**Q: 什么时候需要拆分聚合？**
A: 1) 聚合太大（8+ 实体）；2) 并发冲突严重；3) 不需要强一致性。

---

## 原则追溯

本检查清单基于以下原则：
- `aggregate.md` 1.1-1.3：聚合根识别原则
- `aggregate.md` 2.1-2.6：聚合设计核心原则
- `aggregate.md` 3.1-3.3：聚合边界确定原则
- `aggregate.md` 4.1-4.2：实体识别原则
- `aggregate.md` 5.1-5.2：值对象识别原则
- `aggregate.md` 6.1-6.3：聚合不变量原则
- `aggregate.md` 7.1-7.3：聚合设计模式
