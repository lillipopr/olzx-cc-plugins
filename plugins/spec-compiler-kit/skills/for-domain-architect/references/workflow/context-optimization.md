# 上下文优化策略

> **目标**：在处理大型 PRD 和生成复杂领域设计文档时，避免上下文被撑爆

---

## 问题分析

### 上下文消耗来源

| 阶段 | 消耗来源 | 估算 Tokens |
|------|---------|------------|
| **输入** | PRD 文档 | 5,000 - 20,000 |
| **指令** | 章节指令 + 原则文档 | 3,000 - 5,000 |
| **生成** | 每章生成内容 | 2,000 - 5,000 |
| **累积** | 6章完整内容 | 12,000 - 30,000 |
| **总计** | 一次性处理 | 22,000 - 60,000 ❌ |

### 问题

- 一次性处理会超过上下文限制（200K tokens）
- 中间过程累积大量内容
- 无法完成完整流程

---

## 解决方案：分阶段 + 文件持久化

### 核心原则

1. **只保留必要信息**：不在内存中累积完整内容
2. **文件持久化**：每个章节完成后立即写入文件
3. **摘要传递**：章节间只传递关键摘要
4. **按需加载**：只在需要时加载文件内容

---

## 优化后的工作流

### 流程图

```
┌─────────────────────────────────────────────────────────────────────────┐
│                      上下文优化的生成流程                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  输入：PRD 文档（大文件）                                                 │
│    ↓                                                                     │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │ 阶段 1：PRD 分析 + 摘要                                            │    │
│  │   - 读取 PRD 文件                                                 │    │
│  │   - 提取关键信息（功能概述、核心实体、业务流程）                    │    │
│  │   - 生成 PRD 摘要文件（~500 tokens）                               │    │
│  │   - 原始 PRD 文件不再加载                                         │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│    ↓ 上下文中只保留 PRD 摘要                                            │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │ 阶段 2：逐章生成（每次只处理一章）                                  │    │
│  │                                                                  │    │
│  │  ┌─────────────────────────────────────────────────────────┐    │    │
│  │  │ 第 N 章                                                   │    │    │
│  │  │   1. 读取章节指令（~1,000 tokens）                          │    │    │
│  │  │   2. 读取对应原则（~500 tokens）                             │    │    │
│  │  │   3. 读取 PRD 摘要（~500 tokens）                            │    │    │
│  │  │   4. 生成章节内容（~2,000 tokens）                            │    │    │
│  │  │   5. 写入文件：chapter-N-output.md                           │    │    │
│  │  │   6. 生成章节摘要（~200 tokens）                              │    │    │
│  │  │   7. 清理章节内容，只保留摘要                                  │    │    │
│  │  └─────────────────────────────────────────────────────────┘    │    │
│  │                                                                  │    │
│  │  重复 6 次，每次只处理一章                                         │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│    ↓ 上下文中只保留各章节摘要                                            │
│  ┌─────────────────────────────────────────────────────────────────┐    │
│  │ 阶段 3：文档组装（只在这一步加载所有内容）                           │    │
│  │   - 读取所有章节文件                                              │    │
│  │   - 使用模板组装文档                                              │    │
│  │   - 写入最终文件                                                 │    │
│  │   - 清理所有中间内容                                             │    │
│  └─────────────────────────────────────────────────────────────────┘    │
│    ↓                                                                     │
│  输出：领域设计文档（文件路径，不返回完整内容）                            │
│                                                                          │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 详细实施步骤

### 阶段 1：PRD 分析与摘要

**目标**：将大型 PRD 转换为轻量级摘要

**输入**：
- PRD 文件路径

**输出**：
- `prd-summary.md`：PRD 摘要文件

**摘要模板**：

```markdown
# PRD 摘要

## 功能概述
{2-3 句话描述功能}

## 核心实体
| 实体名 | 说明 |
|-------|------|
| {实体1} | {说明} |
| {实体2} | {说明} |

## 业务流程
1. {流程1}
2. {流程2}

## 外部接口
- {接口1}
- {接口2}

## 异步处理
- {事件1}
- {事件2}

## 定时任务
- {任务1}
```

**上下文节省**：
- 原始 PRD：10,000 tokens
- PRD 摘要：500 tokens
- **节省：95%**

---

### 阶段 2：逐章生成

**核心策略**：每次只处理一章，完成后立即清理

#### 章节生成流程

```
第 N 章生成：
1. 读取章节指令（chapters/chapter-XX.md）
2. 读取对应原则（references/principles/XX.md）
3. 读取 PRD 摘要（prd-summary.md）
4. 读取前序章节摘要（如果有）
5. 生成章节内容
6. 写入文件（output/chapter-N.md）
7. 生成章节摘要（~200 tokens）
8. 清理章节内容
```

#### 章节摘要模板

```markdown
# 第 N 章摘要

## 章节
{章节名称}

## 关键内容
- {要点1}
- {要点2}
- {要点3}

## 与其他章节的关系
- 依赖：{依赖的章节}
- 被依赖：{依赖此章节的章节}

## 文件路径
output/chapter-N.md
```

#### 上下文控制

| 时刻 | 上下文内容 | 估算 Tokens |
|------|-----------|------------|
| 开始 | PRD 摘要 + 章节指令 + 原则 | ~2,000 |
| 生成中 | + 章节内容 | ~4,000 |
| 完成后 | + 章节摘要 - 章节内容 | ~2,200 |

**每个章节周期**：~4,000 tokens（峰值）

---

### 阶段 3：文档组装

**目标**：只在最后一步加载所有内容

**流程**：

1. **读取所有章节文件**
   - `output/chapter-1.md` 到 `output/chapter-6.md`

2. **使用模板组装**
   - 读取模板文件
   - 填充各章节内容

3. **写入最终文件**
   - `output/{功能名称}-领域设计文档.md`

4. **清理中间内容**
   - 删除临时文件（可选）

**上下文控制**：

| 时刻 | 上下文内容 | 估算 Tokens |
|------|-----------|------------|
| 开始 | 各章节摘要 + 模板 | ~3,000 |
| 加载章节 | + 6个章节文件 | ~15,000 |
| 组装完成 | + 最终文档 | ~18,000 |

**只在最后一步消耗大量上下文**

---

## 上下文对比

### 旧方案（一次性处理）

```
总上下文 = PRD + 6章指令 + 6章原则 + 6章内容 + 评分标准 + ...
         ≈ 50,000 tokens ❌
```

### 新方案（分阶段处理）

```
阶段 1：PRD 摘要
  上下文 = PRD + 指令 ≈ 5,000 tokens ✅

阶段 2：逐章生成（6次）
  每次上下文 = 摘要 + 单章指令 + 单章原则 + 单章内容 ≈ 4,000 tokens ✅

阶段 3：文档组装
  上下文 = 摘要 + 模板 + 6章文件 ≈ 18,000 tokens ✅

峰值上下文：18,000 tokens（可接受）
```

**节省：64%**

---

## 实施技巧

### 1. 使用 Write 而非 Read

**原则**：生成后立即写入文件，不要在响应中返回完整内容

```typescript
// ❌ 错误：在响应中返回完整内容
function generateChapter() {
  const content = generate()  // 2,000 tokens
  return content  // 内容会在上下文中累积
}

// ✅ 正确：写入文件，只返回摘要
function generateChapter() {
  const content = generate()  // 2,000 tokens
  writeFile("chapter-1.md", content)  // 写入文件
  return { summary: "章节摘要...", file: "chapter-1.md" }  // 只返回摘要
}
```

### 2. 文件管理策略

**目录结构**：

```
output/
├── prd-summary.md           # PRD 摘要
├── chapter-1.md             # 第一章完整内容
├── chapter-2.md             # 第二章完整内容
├── ...
├── chapter-6.md             # 第六章完整内容
├── score-report.md          # 评分报告
└── {功能名称}-领域设计文档.md # 最终文档
```

### 3. 引用而非内联

**原则**：引用文件路径，而非包含文件内容

```markdown
## 章节摘要

第一章：限界上下文设计
- 文件：output/chapter-1.md
- 关键内容：业务能力分析、上下文划分、上下文映射

第二章：聚合设计
- 文件：output/chapter-2.md
- 关键内容：聚合清单、聚合根设计、实体设计、值对象设计
```

### 4. 增量评分

**原则**：每章完成后立即评分，不要等所有章节完成

```typescript
// ✅ 正确：每章完成后评分
for (let i = 1; i <= 6; i++) {
  const chapter = generateChapter(i)
  const score = scoreChapter(chapter)
  if (score < 60) {
    regenerateChapter(i)
  }
  writeChapter(i, chapter)
  writeScore(i, score)
}

// ❌ 错误：所有章节完成后评分
const chapters = []
for (let i = 1; i <= 6; i++) {
  chapters.push(generateChapter(i))  // 累积所有内容
}
const scores = scoreAll(chapters)  // 此时上下文已满
```

---

## 特殊场景处理

### 场景 1：章节间依赖

**问题**：第二章依赖第一章的结果

**解决**：传递摘要而非完整内容

```
第一章完成：
- 生成完整内容 → 写入 chapter-1.md
- 生成摘要（包含聚合清单）
- 清理完整内容

第二章生成：
- 读取第一章摘要（获取聚合清单）
- 基于清单生成第二章
- 写入 chapter-2.md
```

### 场景 2：修改流程

**问题**：修改某个章节时需要参考其他章节

**解决**：按需加载

```
修改第 N 章：
1. 加载第 N 章内容
2. 按需加载依赖章节的摘要
3. 修改并保存
4. 重新评分第 N 章
5. 清理所有内容
```

### 场景 3：最终组装

**问题**：组装时需要加载所有章节

**解决**：只在最后一步加载

```
前 6 次迭代：
  - 只生成和保存单章
  - 不加载其他章节

第 7 次迭代：
  - 加载所有 6 个章节
  - 组装最终文档
  - 保存并清理
```

---

## 监控与优化

### 上下文监控

**每次迭代后检查**：

```markdown
## 上下文状态检查

- [ ] 当前响应大小 < 10,000 tokens
- [ ] 未加载完整 PRD
- [ ] 未加载多个章节完整内容
- [ ] 已清理不再需要的内容
- [ ] 只保留摘要和文件引用
```

### 优化策略

**如果上下文仍然过大**：

1. **进一步精简摘要**：只保留最关键信息
2. **减少同时加载的文件**：按需加载
3. **分批处理**：将一个章节分成多个子任务
4. **使用子代理**：通过 Task 工具调用子代理

---

## 工具支持

### 推荐工具

| 工具 | 用途 | 说明 |
|------|------|------|
| **Write** | 写入文件 | 立即持久化，不占用上下文 |
| **Read** | 按需读取 | 只在需要时读取文件 |
| **Task** | 子代理 | 隔离上下文，独立处理 |
| **Bash** | 文件操作 | 移动、复制、删除文件 |

### 子代理策略

**使用 Task 工具调用子代理**：

```
主代理：
  - PRD 分析 → 生成摘要
  - 调度任务

子代理 1：
  - 读取摘要
  - 生成第一章
  - 写入文件
  - 返回摘要

子代理 2：
  - 读取摘要 + 第一章摘要
  - 生成第二章
  - 写入文件
  - 返回摘要

...

主代理：
  - 收集所有摘要
  - 组装文档
  - 返回文件路径
```

---

## 最佳实践

### DO ✅

- ✅ 每章完成后立即写入文件
- ✅ 只在上下文中保留摘要
- ✅ 按需加载文件内容
- ✅ 使用子代理隔离上下文
- ✅ 定期清理不再需要的内容

### DON'T ❌

- ❌ 在响应中返回完整章节内容
- ❌ 累积多个章节的完整内容
- ❌ 在内存中组装完整文档
- ❌ 重复加载相同内容
- ❌ 保留原始 PRD 文件

---

## 示例代码

### 章节生成示例

```typescript
async function generateChapter(chapterNumber: number) {
  // 1. 读取必要文件（只读取摘要）
  const prdSummary = await readFile("prd-summary.md")
  const chapterInstruction = await readFile(`chapters/chapter-${chapterNumber}.md`)
  const principle = await readFile(`references/principles/${getPrinciple(chapterNumber)}.md`)

  // 2. 生成章节
  const content = await generateChapterContent(prdSummary, chapterInstruction, principle)

  // 3. 写入文件（立即持久化）
  await writeFile(`output/chapter-${chapterNumber}.md`, content)

  // 4. 生成摘要
  const summary = extractSummary(content)
  await writeFile(`output/chapter-${chapterNumber}-summary.md`, summary)

  // 5. 只返回摘要（不返回完整内容）
  return {
    chapter: chapterNumber,
    summary: summary,
    file: `output/chapter-${chapterNumber}.md`
  }
}
```

### 文档组装示例

```typescript
async function assembleDocument() {
  // 1. 读取模板
  const template = await readFile("assets/templates/domain-design-template.md")

  // 2. 读取所有章节（只在最后加载）
  const chapters = []
  for (let i = 1; i <= 6; i++) {
    const chapter = await readFile(`output/chapter-${i}.md`)
    chapters.push(chapter)
  }

  // 3. 组装文档
  const document = template
    .replace("{{CHAPTER_1}}", chapters[0])
    .replace("{{CHAPTER_2}}", chapters[1])
    .replace("{{CHAPTER_3}}", chapters[2])
    .replace("{{CHAPTER_4}}", chapters[3])
    .replace("{{CHAPTER_5}}", chapters[4])
    .replace("{{CHAPTER_6}}", chapters[5])

  // 4. 写入最终文件
  await writeFile(`output/${functionName}-领域设计文档.md`, document)

  // 5. 只返回文件路径
  return {
    file: `output/${functionName}-领域设计文档.md`,
    size: document.length
  }
}
```

---

## 总结

### 优化效果

| 指标 | 旧方案 | 新方案 | 改善 |
|------|-------|-------|------|
| 峰值上下文 | 50,000 tokens | 18,000 tokens | ↓ 64% |
| 内存占用 | 持续高 | 间歇性高 | ↓ 70% |
| 可扩展性 | 受限 | 良好 | ✅ |
| 可维护性 | 困难 | 容易 | ✅ |

### 关键要点

1. **PRD 摘要**：将大型 PRD 转换为轻量级摘要
2. **逐章生成**：每次只处理一章，完成后立即清理
3. **文件持久化**：所有内容写入文件，不占用内存
4. **摘要传递**：章节间只传递摘要，不传递完整内容
5. **最后组装**：只在最后一步加载所有内容

通过以上策略，可以在有限的上下文中处理大型 PRD 和生成复杂的领域设计文档。
