# 用例设计 SOP（第四部分）

> **跨端一致性**：本部分产出的用例适用于所有端（后端/iOS/前端）。
> 各端测试时使用相同的用例数据和预期结果。

## 目标

为每个约束设计验证用例，确保系统行为可测试、可验证。

## 核心原则

- 用例覆盖所有不变量和状态转移
- Bad Case 覆盖所有禁止态
- 用例可直接转化为自动化测试
- 用例优先级分配合理（P0 <= 30%）

---

## 用例类型（完整覆盖）

完整的用例体系应包含 6 类：

1️⃣ **正向用例**（Happy Path） - 核心业务流程
2️⃣ **边界用例**（Boundary Cases） - 上下限、极端值
3️⃣ **Bad Case**（禁止态） - 系统必须拒绝
4️⃣ **回放用例**（Replay Cases） - 可重现性验证
5️⃣ **规则升级用例**（Version Cases） - 版本兼容性
6️⃣ **可解释性用例**（Explainability Cases） - 结果可追溯

---

## 步骤 1：设计正向用例

### 1.1 正向用例目标

覆盖所有核心 Happy Path，确保系统主要功能正常工作。

### 1.2 正向用例模板

```
### Case-01: {用例名称}

**前置条件（Given）**：
- 系统状态：{状态描述}
- 数据状态：{数据描述}
- 外部依赖状态：{依赖描述}

**触发行为（When）**：
- {用户/系统做了什么}

**预期结果（Then）**：
- 状态变化：{变化描述}
- 输出结果：{输出描述}
- 副作用：{日志、消息、调用}

**约束/不变量**：
- INV-01: {约束描述}
- INV-02: {约束描述}

**各端验证方式**：
| 端 | 验证方式 | 测试文件 |
|----|---------|---------|
| 后端 | 单元测试 / 集成测试 | XxxTest.java |
| iOS | 单元测试 / UI 测试 | XxxTests.swift |
| 前端 | 单元测试 / E2E 测试 | xxx.test.ts |
```

### 1.3 正向用例示例

```
### Case-01: 会员正常每日刷新

**前置条件（Given）**：
- 会员状态 = M1（生效中）
- 今日未刷新
- 点券余额 = 50

**触发行为（When）**：
- 系统触发每日刷新

**预期结果（Then）**：
- 状态变化：M1 → M1（不变）
- 输出结果：点券 +100
- 副作用：记录发放日志

**约束/不变量**：
- INV-01: 只有 M1 状态才能发放
- INV-02: 每日最多发放一次
- INV-03: 单次发放不超过 100

**各端验证方式**：
| 端 | 验证方式 | 测试文件 |
|----|---------|---------|
| 后端 | 单元测试 | CouponDomainTest.java |
| iOS | 单元测试 | CouponServiceTests.swift |
| 前端 | 单元测试 | couponService.test.ts |
```

---

## 步骤 2：设计 Bad Case

### 2.1 Bad Case 目标

覆盖所有禁止态，确保系统能正确拒绝非法操作。

### 2.2 Bad Case 模板

```
### Case-B1: {用例名称}

**前置条件（Given）**：
- {状态描述}

**触发行为（When）**：
- {触发描述}

**预期结果（Then）**：
- 状态变化：无（或状态回滚）
- 输出结果：拒绝操作，返回错误 "{错误信息}"
- 副作用：无

**约束/不变量**：
- {违反的不变量ID}: {约束描述}
```

### 2.3 Bad Case 示例

```
### Case-B1: 非会员刷新被拒绝

**前置条件（Given）**：
- 会员状态 = M0（非会员）

**触发行为（When）**：
- 系统触发刷新

**预期结果（Then）**：
- 状态变化：无
- 输出结果：拒绝发放，返回错误 "INV-01: 非会员不能发放点券"
- 副作用：无

**约束/不变量**：
- INV-01: 只有 M1 状态才能发放（违反）

**各端验证方式**：
| 端 | 验证方式 | 测试文件 |
|----|---------|---------|
| 后端 | 单元测试 | CouponDomainTest.java |
| iOS | 单元测试 | CouponServiceTests.swift |
| 前端 | - | 后端校验 |
```

---

## 步骤 3：设计边界用例

### 3.1 边界用例目标

覆盖边界条件，确保系统在临界值处行为正确。

### 3.2 边界用例类型

| 类型 | 描述 | 示例 |
|------|------|------|
| 零值 | 数量为 0 的情况 | 库存 = 0 时购买 |
| 最大值 | 数量达到上限 | 点券发放 = 100 |
| 最小值 | 数量达到下限 | 会员到期前 1 天 |
| 空集合 | 集合为空 | 购物车为空时结算 |

### 3.3 边界用例示例

```
### Case-E1: 库存恰好等于购买数量

**前置条件（Given）**：
- 商品库存 = 5
- 用户购买数量 = 5

**触发行为（When）**：
- 用户提交订单

**预期结果（Then）**：
- 订单创建成功
- 库存变为 0

**约束/不变量**：
- INV-02: 库存 >= 0
```

---

## 步骤 4：设计高级用例（可选）

### 4.1 回放用例

验证历史结果可重现。

```
### Case-R1: 历史结果回放

**前置条件（Given）**：
- 历史记录 ID: XXX
- 规则版本: v1.0.0
- 原始结果: {结果}

**触发行为（When）**：
- 使用规则 v1.0.0 重新计算

**预期结果（Then）**：
- 新结果 = 原始结果
- 所有指标值一致

**验证**：
```
ASSERT recalculate(record, v1.0) == original_result
```
```

### 4.2 规则升级用例

验证版本升级的兼容性。

```
### Case-V1: 规则升级兼容性

**前置条件（Given）**：
- 同一记录
- 规则 v1.0: {公式1}
- 规则 v2.0: {公式2}

**触发行为（When）**：
- 分别用 v1 和 v2 计算

**预期结果（Then）**：
- v2 结果 >= v1 结果（单调性）
- 差异可解释
- v1 和 v2 结果都有记录
```

### 4.3 可解释性用例

验证结果可追溯。

```
### Case-X1: 测评结果可追溯

**前置条件（Given）**：
- 用户完成测评
- 测评结果已生成

**触发行为（When）**：
- 用户点击"查看结果说明"

**预期结果（Then）**：
- 显示每个维度的得分来源
- 显示影响的题目列表
- 显示判定逻辑

**约束/不变量**：
- EXP-01: 结果可追溯
```

---

## 步骤 5：生成用例覆盖矩阵

### 5.1 覆盖矩阵模板

| 用例ID | 类型 | 覆盖不变量 | 覆盖状态转移 | 优先级 |
|--------|------|------------|--------------|--------|
| Case-01 | 正向 | INV-01, INV-02 | S0→S1 | P0 |
| Case-B1 | Bad | INV-01 | 禁止态 | P0 |
| Case-E1 | 边界 | INV-02 | S1→S2 | P1 |

### 5.2 覆盖完整性检查

- [ ] 每个不变量至少有一个用例覆盖
- [ ] 每个状态转移至少有一个用例覆盖
- [ ] 每个禁止态至少有一个 Bad Case
- [ ] P0 用例 100% 覆盖
- [ ] 用例可直接转化为自动化测试

---

## 步骤 6：定义用例优先级

### 6.1 优先级定义

| 优先级 | 定义 | 比例要求 | 示例 |
|-------|------|---------|------|
| **P0** | 核心业务流程，必须实现 | ≤ 30% | 会员订阅成功 |
| **P1** | 重要边界条件，应实现 | ≤ 40% | 库存恰好售罄 |
| **P2** | 边缘场景，可延后 | ≤ 30% | 并发创建订单 |

### 6.2 用例优先级列表

| 用例ID | 优先级 | 实现顺序 | 依赖 |
|--------|--------|---------|------|
| Case-01 | P0 | 1 | 无 |
| Case-B1 | P0 | 2 | 无 |
| Case-E1 | P1 | 3 | Case-01 |

---

## 闸口检查

用例设计完成后，必须通过以下检查：

- [ ] 每个不变量至少有一个用例覆盖
- [ ] 每个状态转移至少有一个用例覆盖
- [ ] 每个禁止态至少有一个 Bad Case
- [ ] P0 用例 100% 覆盖
- [ ] 用例可直接转化为自动化测试
- [ ] 用例覆盖矩阵完整
- [ ] 用例优先级分配合理（P0 <= 30%）

---

## 自我验证

在完成设计前，确认：

- [ ] 正向用例覆盖所有核心 Happy Path
- [ ] Bad Case 覆盖所有禁止态
- [ ] 边界用例覆盖所有临界值
- [ ] 用例覆盖矩阵完整
- [ ] 各端验证方式已明确
- [ ] 用例优先级分配合理

---

## 常见错误

### ❌ 错误 1：用例覆盖不完整

```
错误：只有正向用例
正确：正向用例 + Bad Case + 边界用例
```

### ❌ 错误 2：Bad Case 遗漏禁止态

```
错误：Bad Case 只覆盖部分禁止态
正确：每个禁止态都有对应的 Bad Case
```

### ❌ 错误 3：用例不可测试

```
错误："用户正常使用"
正确："Given: 会员状态=M1，When: 触发刷新，Then: 点券+100"
```

---

## 用例设计速查表

### 用例类型对应表

| 约束类型 | 应设计的用例类型 |
|---------|----------------|
| 结构约束 | 正向用例 + Bad Case |
| 业务约束 | 正向用例 + Bad Case + 边界用例 |
| 状态约束 | 正向用例（覆盖每个转移）+ Bad Case（禁止态） |
| 版本约束 | 回放用例 + 规则升级用例 |
| 可解释性约束 | 可解释性用例 |

---

**完成** → 返回 [主流程 SOP](sop-main-flow.md)
